#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 03/18/1994 15:52 UTC by sost@netlib2
# Source directory /netlib/blas
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#  10133 -rw-rw-r-- cgbmv.f
#  10384 -rw-rw-r-- cgemv.f
#  10220 -rw-rw-r-- chbmv.f
#   8407 -rw-rw-r-- chemv.f
#   8649 -rw-rw-r-- chpmv.f
#  13031 -rw-rw-r-- ctbmv.f
#  11203 -rw-rw-r-- ctpmv.f
#  10456 -rw-rw-r-- ctrmv.f
#   9372 -rw-rw-r-- dgbmv.f
#   9630 -rw-rw-r-- dgemv.f
#   9910 -rw-rw-r-- dsbmv.f
#   8277 -rw-rw-r-- dspmv.f
#   8149 -rw-rw-r-- dsymv.f
#  11432 -rw-rw-r-- dtbmv.f
#   9521 -rw-rw-r-- dtpmv.f
#   8939 -rw-rw-r-- dtrmv.f
#   9372 -rw-rw-r-- sgbmv.f
#   7481 -rw-rw-r-- sgemv.f
#   9910 -rw-rw-r-- ssbmv.f
#   8277 -rw-rw-r-- sspmv.f
#   8149 -rw-rw-r-- ssymv.f
#  11432 -rw-rw-r-- stbmv.f
#   9521 -rw-rw-r-- stpmv.f
#   8939 -rw-rw-r-- strmv.f
#  10136 -rw-rw-r-- zgbmv.f
#  10387 -rw-rw-r-- zgemv.f
#  10225 -rw-rw-r-- zhbmv.f
#   8412 -rw-rw-r-- zhemv.f
#   8654 -rw-rw-r-- zhpmv.f
#  13040 -rw-rw-r-- ztbmv.f
#  11212 -rw-rw-r-- ztpmv.f
#  10465 -rw-rw-r-- ztrmv.f
#  13158 -rw-rw-r-- ctbsv.f
#  11403 -rw-rw-r-- ctpsv.f
#  10619 -rw-rw-r-- ctrsv.f
#  11553 -rw-rw-r-- dtbsv.f
#   9690 -rw-rw-r-- dtpsv.f
#   9096 -rw-rw-r-- dtrsv.f
#  11553 -rw-rw-r-- stbsv.f
#   9690 -rw-rw-r-- stpsv.f
#   9096 -rw-rw-r-- strsv.f
#  13167 -rw-rw-r-- ztbsv.f
#  11412 -rw-rw-r-- ztpsv.f
#  10628 -rw-rw-r-- ztrsv.f
#   4443 -rw-rw-r-- dger.f
#   4443 -rw-rw-r-- sger.f
#   4455 -rw-rw-r-- cgeru.f
#   4455 -rw-rw-r-- zgeru.f
#   4489 -rw-rw-r-- cgerc.f
#   4492 -rw-rw-r-- zgerc.f
#   6875 -rw-rw-r-- cher.f
#   6880 -rw-rw-r-- zher.f
#   7106 -rw-rw-r-- chpr.f
#   7111 -rw-rw-r-- zhpr.f
#   8494 -rw-rw-r-- cher2.f
#   8503 -rw-rw-r-- zher2.f
#   8601 -rw-rw-r-- chpr2.f
#   8610 -rw-rw-r-- zhpr2.f
#   6041 -rw-rw-r-- dsyr.f
#   6041 -rw-rw-r-- ssyr.f
#   6081 -rw-rw-r-- dspr.f
#   6081 -rw-rw-r-- sspr.f
#   7419 -rw-rw-r-- dsyr2.f
#   7419 -rw-rw-r-- ssyr2.f
#   7358 -rw-rw-r-- dspr2.f
#   7358 -rw-rw-r-- sspr2.f
#   2405 -rw-r--r-- lsame.f
#   1055 -rw-rw-r-- xerbla.f
#
# ============= cgbmv.f ==============
if test -f 'cgbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping cgbmv.f (File already exists)'
else
echo 'x - extracting cgbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cgbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE CGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA, BETA
X      INTEGER            INCX, INCY, KL, KU, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CGBMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
*
*     y := alpha*conjg( A' )*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n band matrix, with kl sub-diagonals and ku super-diagonals.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  KL     - INTEGER.
*           On entry, KL specifies the number of sub-diagonals of the
*           matrix A. KL must satisfy  0 .le. KL.
*           Unchanged on exit.
*
*  KU     - INTEGER.
*           On entry, KU specifies the number of super-diagonals of the
*           matrix A. KU must satisfy  0 .le. KU.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry, the leading ( kl + ku + 1 ) by n part of the
*           array A must contain the matrix of coefficients, supplied
*           column by column, with the leading diagonal of the matrix in
*           row ( ku + 1 ) of the array, the first super-diagonal
*           starting at position 2 in row ku, the first sub-diagonal
*           starting at position 1 in row ( ku + 2 ), and so on.
*           Elements in the array A that do not correspond to elements
*           in the band matrix (such as the top left ku by ku triangle)
*           are not referenced.
*           The following program segment will transfer a band matrix
*           from conventional full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    K = KU + 1 - J
*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
*                       A( K + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( kl + ku + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX         .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ONE
X      PARAMETER        ( ONE  = ( 1.0E+0, 0.0E+0 ) )
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KUP1, KX, KY,
X     $                   LENX, LENY
X      LOGICAL            NOCONJ
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( KL.LT.0 )THEN
X         INFO = 4
X      ELSE IF( KU.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( KL + KU + 1 ) )THEN
X         INFO = 8
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 10
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 13
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CGBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the band part of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KUP1 = KU + 1
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  K    = KUP1 - J
X                  DO 50, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( I ) = Y( I ) + TEMP*A( K + I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  K    = KUP1 - J
X                  DO 70, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( IY ) = Y( IY ) + TEMP*A( K + I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               IF( J.GT.KU )
X     $            KY = KY + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 110, J = 1, N
X               TEMP = ZERO
X               K    = KUP1 - J
X               IF( NOCONJ )THEN
X                  DO 90, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + A( K + I, J )*X( I )
X   90             CONTINUE
X               ELSE
X                  DO 100, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + CONJG( A( K + I, J ) )*X( I )
X  100             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  110       CONTINUE
X         ELSE
X            DO 140, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               K    = KUP1 - J
X               IF( NOCONJ )THEN
X                  DO 120, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + A( K + I, J )*X( IX )
X                     IX   = IX   + INCX
X  120             CONTINUE
X               ELSE
X                  DO 130, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + CONJG( A( K + I, J ) )*X( IX )
X                     IX   = IX   + INCX
X  130             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X               IF( J.GT.KU )
X     $            KX = KX + INCX
X  140       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CGBMV .
*
X      END
SHAR_EOF
chmod 0664 cgbmv.f ||
echo 'restore of cgbmv.f failed'
Wc_c="`wc -c < 'cgbmv.f'`"
test 10133 -eq "$Wc_c" ||
	echo 'cgbmv.f: original size 10133, current size' "$Wc_c"
fi
# ============= cgemv.f ==============
if test -f 'cgemv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping cgemv.f (File already exists)'
else
echo 'x - extracting cgemv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cgemv.f' &&
*
************************************************************************
*
*     File of the COMPLEX          Level-2 BLAS.
*     ==========================================
*
*     SUBROUTINE CGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE CGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE CHEMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE CHBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE CHPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*
*     SUBROUTINE CTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*
*     SUBROUTINE CTBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*
*     SUBROUTINE CTPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*
*     SUBROUTINE CTRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*
*     SUBROUTINE CTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*
*     SUBROUTINE CTPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*
*     SUBROUTINE CGERU ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE CGERC ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE CHER  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*
*     SUBROUTINE CHPR  ( UPLO, N, ALPHA, X, INCX, AP )
*
*     SUBROUTINE CHER2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE CHPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*
*     See:
*
*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J..
*        An  extended  set of Fortran  Basic Linear Algebra Subprograms.
*
*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics
*        and  Computer Science  Division,  Argonne  National Laboratory,
*        9700 South Cass Avenue, Argonne, Illinois 60439, US.
*
*        Or
*
*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms
*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford
*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st
*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA.
*
************************************************************************
*
X      SUBROUTINE CGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
*
*     y := alpha*conjg( A' )*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX         .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry with BETA non-zero, the incremented array Y
*           must contain the vector y. On exit, Y is overwritten by the
*           updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ONE
X      PARAMETER        ( ONE  = ( 1.0E+0, 0.0E+0 ) )
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
X      LOGICAL            NOCONJ
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CGEMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  DO 50, I = 1, M
X                     Y( I ) = Y( I ) + TEMP*A( I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  DO 70, I = 1, M
X                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 110, J = 1, N
X               TEMP = ZERO
X               IF( NOCONJ )THEN
X                  DO 90, I = 1, M
X                     TEMP = TEMP + A( I, J )*X( I )
X   90             CONTINUE
X               ELSE
X                  DO 100, I = 1, M
X                     TEMP = TEMP + CONJG( A( I, J ) )*X( I )
X  100             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  110       CONTINUE
X         ELSE
X            DO 140, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               IF( NOCONJ )THEN
X                  DO 120, I = 1, M
X                     TEMP = TEMP + A( I, J )*X( IX )
X                     IX   = IX   + INCX
X  120             CONTINUE
X               ELSE
X                  DO 130, I = 1, M
X                     TEMP = TEMP + CONJG( A( I, J ) )*X( IX )
X                     IX   = IX   + INCX
X  130             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  140       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CGEMV .
*
X      END
SHAR_EOF
chmod 0664 cgemv.f ||
echo 'restore of cgemv.f failed'
Wc_c="`wc -c < 'cgemv.f'`"
test 10384 -eq "$Wc_c" ||
	echo 'cgemv.f: original size 10384, current size' "$Wc_c"
fi
# ============= chbmv.f ==============
if test -f 'chbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping chbmv.f (File already exists)'
else
echo 'x - extracting chbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'chbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE CHBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA, BETA
X      INTEGER            INCX, INCY, K, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CHBMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n hermitian band matrix, with k super-diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the band matrix A is being supplied as
*           follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  being supplied.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  being supplied.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry, K specifies the number of super-diagonals of the
*           matrix A. K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the hermitian matrix, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer the upper
*           triangular part of a hermitian band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the hermitian matrix, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer the lower
*           triangular part of a hermitian band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that the imaginary parts of the diagonal elements need
*           not be set and are assumed to be zero.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX         .
*           On entry, BETA specifies the scalar beta.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ONE
X      PARAMETER        ( ONE  = ( 1.0E+0, 0.0E+0 ) )
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KPLUS1, KX, KY, L
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, MIN, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( K.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array A
*     are accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when upper triangle of A is stored.
*
X         KPLUS1 = K + 1
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               L     = KPLUS1 - J
X               DO 50, I = MAX( 1, J - K ), J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + CONJG( A( L + I, J ) )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*REAL( A( KPLUS1, J ) )
X     $                         + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               L     = KPLUS1 - J
X               DO 70, I = MAX( 1, J - K ), J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + CONJG( A( L + I, J ) )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*REAL( A( KPLUS1, J ) )
X     $                           + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               IF( J.GT.K )THEN
X                  KX = KX + INCX
X                  KY = KY + INCY
X               END IF
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when lower triangle of A is stored.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J ) + TEMP1*REAL( A( 1, J ) )
X               L      = 1      - J
X               DO 90, I = J + 1, MIN( N, J + K )
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + CONJG( A( L + I, J ) )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY ) + TEMP1*REAL( A( 1, J ) )
X               L       = 1       - J
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, MIN( N, J + K )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + CONJG( A( L + I, J ) )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHBMV .
*
X      END
SHAR_EOF
chmod 0664 chbmv.f ||
echo 'restore of chbmv.f failed'
Wc_c="`wc -c < 'chbmv.f'`"
test 10220 -eq "$Wc_c" ||
	echo 'chbmv.f: original size 10220, current size' "$Wc_c"
fi
# ============= chemv.f ==============
if test -f 'chemv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping chemv.f (File already exists)'
else
echo 'x - extracting chemv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'chemv.f' &&
*
************************************************************************
*
X      SUBROUTINE CHEMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CHEMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n hermitian matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the hermitian matrix and the strictly
*           lower triangular part of A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the hermitian matrix and the strictly
*           upper triangular part of A is not referenced.
*           Note that the imaginary parts of the diagonal elements need
*           not be set and are assumed to be zero.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX         .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ONE
X      PARAMETER        ( ONE  = ( 1.0E+0, 0.0E+0 ) )
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 5
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 10
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHEMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when A is stored in upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + CONJG( A( I, J ) )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*REAL( A( J, J ) ) + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, I = 1, J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + CONJG( A( I, J ) )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*REAL( A( J, J ) ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when A is stored in lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J ) + TEMP1*REAL( A( J, J ) )
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + CONJG( A( I, J ) )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY ) + TEMP1*REAL( A( J, J ) )
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, N
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + CONJG( A( I, J ) )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHEMV .
*
X      END
SHAR_EOF
chmod 0664 chemv.f ||
echo 'restore of chemv.f failed'
Wc_c="`wc -c < 'chemv.f'`"
test 8407 -eq "$Wc_c" ||
	echo 'chemv.f: original size 8407, current size' "$Wc_c"
fi
# ============= chpmv.f ==============
if test -f 'chpmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping chpmv.f (File already exists)'
else
echo 'x - extracting chpmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'chpmv.f' &&
*
************************************************************************
*
X      SUBROUTINE CHPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA, BETA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CHPMV  performs the matrix-vector operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n hermitian matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  AP     - COMPLEX          array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on.
*           Note that the imaginary parts of the diagonal elements need
*           not be set and are assumed to be zero.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX         .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ONE
X      PARAMETER        ( ONE  = ( 1.0E+0, 0.0E+0 ) )
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 6
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when AP contains the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               K     = KK
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + CONJG( AP( K ) )*X( I )
X                  K      = K      + 1
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*REAL( AP( KK + J - 1 ) )
X     $                         + ALPHA*TEMP2
X               KK     = KK     + J
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, K = KK, KK + J - 2
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + CONJG( AP( K ) )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*REAL( AP( KK + J - 1 ) )
X     $                           + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + J
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when AP contains the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J ) + TEMP1*REAL( AP( KK ) )
X               K      = KK     + 1
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + CONJG( AP( K ) )*X( I )
X                  K      = K      + 1
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X               KK     = KK     + ( N - J + 1 )
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY ) + TEMP1*REAL( AP( KK ) )
X               IX      = JX
X               IY      = JY
X               DO 110, K = KK + 1, KK + N - J
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + CONJG( AP( K ) )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + ( N - J + 1 )
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHPMV .
*
X      END
SHAR_EOF
chmod 0664 chpmv.f ||
echo 'restore of chpmv.f failed'
Wc_c="`wc -c < 'chpmv.f'`"
test 8649 -eq "$Wc_c" ||
	echo 'chpmv.f: original size 8649, current size' "$Wc_c"
fi
# ============= ctbmv.f ==============
if test -f 'ctbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ctbmv.f (File already exists)'
else
echo 'x - extracting ctbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ctbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE CTBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CTBMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CTBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX   too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*         Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = KPLUS1 - J
X                     DO 10, I = MAX( 1, J - K ), J - 1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( KPLUS1, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = KPLUS1  - J
X                     DO 30, I = MAX( 1, J - K ), J - 1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( KPLUS1, J )
X                  END IF
X                  JX = JX + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = 1      - J
X                     DO 50, I = MIN( N, J + K ), J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( 1, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = 1       - J
X                     DO 70, I = MIN( N, J + K ), J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( 1, J )
X                  END IF
X                  JX = JX - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x  or  x := conjg( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( KPLUS1, J )
X                     DO 90, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + A( L + I, J )*X( I )
X   90                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( KPLUS1, J ) )
X                     DO 100, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + CONJG( A( L + I, J ) )*X( I )
X  100                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 140, J = N, 1, -1
X                  TEMP = X( JX )
X                  KX   = KX      - INCX
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( KPLUS1, J )
X                     DO 120, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + A( L + I, J )*X( IX )
X                        IX   = IX   - INCX
X  120                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( KPLUS1, J ) )
X                     DO 130, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + CONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   - INCX
X  130                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = 1, N
X                  TEMP = X( J )
X                  L    = 1      - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( 1, J )
X                     DO 150, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + A( L + I, J )*X( I )
X  150                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( 1, J ) )
X                     DO 160, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + CONJG( A( L + I, J ) )*X( I )
X  160                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               JX = KX
X               DO 200, J = 1, N
X                  TEMP = X( JX )
X                  KX   = KX      + INCX
X                  IX   = KX
X                  L    = 1       - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( 1, J )
X                     DO 180, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + A( L + I, J )*X( IX )
X                        IX   = IX   + INCX
X  180                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( 1, J ) )
X                     DO 190, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + CONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   + INCX
X  190                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of CTBMV .
*
X      END
SHAR_EOF
chmod 0664 ctbmv.f ||
echo 'restore of ctbmv.f failed'
Wc_c="`wc -c < 'ctbmv.f'`"
test 13031 -eq "$Wc_c" ||
	echo 'ctbmv.f: original size 13031, current size' "$Wc_c"
fi
# ============= ctpmv.f ==============
if test -f 'ctpmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ctpmv.f (File already exists)'
else
echo 'x - extracting ctpmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ctpmv.f' &&
*
************************************************************************
*
X      SUBROUTINE CTPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX            AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CTPMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX          array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CTPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x:= A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      + 1
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK + J - 1 )
X                  END IF
X                  KK = KK + J
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, K = KK, KK + J - 2
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK + J - 1 )
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      - 1
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK - N + J )
X                  END IF
X                  KK = KK - ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK - N + J )
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x  or  x := conjg( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = N, 1, -1
X                  TEMP = X( J )
X                  K    = KK     - 1
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 90, I = J - 1, 1, -1
X                        TEMP = TEMP + AP( K )*X( I )
X                        K    = K    - 1
X   90                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( AP( KK ) )
X                     DO 100, I = J - 1, 1, -1
X                        TEMP = TEMP + CONJG( AP( K ) )*X( I )
X                        K    = K    - 1
X  100                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   - J
X  110          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 140, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 120, K = KK - 1, KK - J + 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + AP( K )*X( IX )
X  120                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( AP( KK ) )
X                     DO 130, K = KK - 1, KK - J + 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + CONJG( AP( K ) )*X( IX )
X  130                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - J
X  140          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = 1, N
X                  TEMP = X( J )
X                  K    = KK     + 1
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 150, I = J + 1, N
X                        TEMP = TEMP + AP( K )*X( I )
X                        K    = K    + 1
X  150                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( AP( KK ) )
X                     DO 160, I = J + 1, N
X                        TEMP = TEMP + CONJG( AP( K ) )*X( I )
X                        K    = K    + 1
X  160                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   + ( N - J + 1 )
X  170          CONTINUE
X            ELSE
X               JX = KX
X               DO 200, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 180, K = KK + 1, KK + N - J
X                        IX   = IX   + INCX
X                        TEMP = TEMP + AP( K )*X( IX )
X  180                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( AP( KK ) )
X                     DO 190, K = KK + 1, KK + N - J
X                        IX   = IX   + INCX
X                        TEMP = TEMP + CONJG( AP( K ) )*X( IX )
X  190                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + ( N - J + 1 )
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of CTPMV .
*
X      END
SHAR_EOF
chmod 0664 ctpmv.f ||
echo 'restore of ctpmv.f failed'
Wc_c="`wc -c < 'ctpmv.f'`"
test 11203 -eq "$Wc_c" ||
	echo 'ctpmv.f: original size 11203, current size' "$Wc_c"
fi
# ============= ctrmv.f ==============
if test -f 'ctrmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ctrmv.f (File already exists)'
else
echo 'x - extracting ctrmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ctrmv.f' &&
*
************************************************************************
*
X      SUBROUTINE CTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CTRMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CTRMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, I = 1, J - 1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, I = N, J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x  or  x := conjg( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 90, I = J - 1, 1, -1
X                        TEMP = TEMP + A( I, J )*X( I )
X   90                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( J, J ) )
X                     DO 100, I = J - 1, 1, -1
X                        TEMP = TEMP + CONJG( A( I, J ) )*X( I )
X  100                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 140, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 120, I = J - 1, 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + A( I, J )*X( IX )
X  120                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( J, J ) )
X                     DO 130, I = J - 1, 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + CONJG( A( I, J ) )*X( IX )
X  130                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = 1, N
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 150, I = J + 1, N
X                        TEMP = TEMP + A( I, J )*X( I )
X  150                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( J, J ) )
X                     DO 160, I = J + 1, N
X                        TEMP = TEMP + CONJG( A( I, J ) )*X( I )
X  160                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               JX = KX
X               DO 200, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 180, I = J + 1, N
X                        IX   = IX   + INCX
X                        TEMP = TEMP + A( I, J )*X( IX )
X  180                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*CONJG( A( J, J ) )
X                     DO 190, I = J + 1, N
X                        IX   = IX   + INCX
X                        TEMP = TEMP + CONJG( A( I, J ) )*X( IX )
X  190                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of CTRMV .
*
X      END
SHAR_EOF
chmod 0664 ctrmv.f ||
echo 'restore of ctrmv.f failed'
Wc_c="`wc -c < 'ctrmv.f'`"
test 10456 -eq "$Wc_c" ||
	echo 'ctrmv.f: original size 10456, current size' "$Wc_c"
fi
# ============= dgbmv.f ==============
if test -f 'dgbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dgbmv.f (File already exists)'
else
echo 'x - extracting dgbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dgbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE DGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA, BETA
X      INTEGER            INCX, INCY, KL, KU, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DGBMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n band matrix, with kl sub-diagonals and ku super-diagonals.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  KL     - INTEGER.
*           On entry, KL specifies the number of sub-diagonals of the
*           matrix A. KL must satisfy  0 .le. KL.
*           Unchanged on exit.
*
*  KU     - INTEGER.
*           On entry, KU specifies the number of super-diagonals of the
*           matrix A. KU must satisfy  0 .le. KU.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading ( kl + ku + 1 ) by n part of the
*           array A must contain the matrix of coefficients, supplied
*           column by column, with the leading diagonal of the matrix in
*           row ( ku + 1 ) of the array, the first super-diagonal
*           starting at position 2 in row ku, the first sub-diagonal
*           starting at position 1 in row ( ku + 2 ), and so on.
*           Elements in the array A that do not correspond to elements
*           in the band matrix (such as the top left ku by ku triangle)
*           are not referenced.
*           The following program segment will transfer a band matrix
*           from conventional full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    K = KU + 1 - J
*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
*                       A( K + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( kl + ku + 1 ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*     .. Parameters ..
X      DOUBLE PRECISION   ONE         , ZERO
X      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KUP1, KX, KY,
X     $                   LENX, LENY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( KL.LT.0 )THEN
X         INFO = 4
X      ELSE IF( KU.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( KL + KU + 1 ) )THEN
X         INFO = 8
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 10
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 13
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DGBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the band part of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KUP1 = KU + 1
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  K    = KUP1 - J
X                  DO 50, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( I ) = Y( I ) + TEMP*A( K + I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  K    = KUP1 - J
X                  DO 70, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( IY ) = Y( IY ) + TEMP*A( K + I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               IF( J.GT.KU )
X     $            KY = KY + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 100, J = 1, N
X               TEMP = ZERO
X               K    = KUP1 - J
X               DO 90, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                  TEMP = TEMP + A( K + I, J )*X( I )
X   90          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  100       CONTINUE
X         ELSE
X            DO 120, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               K    = KUP1 - J
X               DO 110, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                  TEMP = TEMP + A( K + I, J )*X( IX )
X                  IX   = IX   + INCX
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X               IF( J.GT.KU )
X     $            KX = KX + INCX
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DGBMV .
*
X      END
SHAR_EOF
chmod 0664 dgbmv.f ||
echo 'restore of dgbmv.f failed'
Wc_c="`wc -c < 'dgbmv.f'`"
test 9372 -eq "$Wc_c" ||
	echo 'dgbmv.f: original size 9372, current size' "$Wc_c"
fi
# ============= dgemv.f ==============
if test -f 'dgemv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dgemv.f (File already exists)'
else
echo 'x - extracting dgemv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dgemv.f' &&
*
************************************************************************
*
*     File of the DOUBLE PRECISION  Level-2 BLAS.
*     ===========================================
*
*     SUBROUTINE DGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE DGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE DSYMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE DSBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE DSPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*
*     SUBROUTINE DTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*
*     SUBROUTINE DTBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*
*     SUBROUTINE DTPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*
*     SUBROUTINE DTRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*
*     SUBROUTINE DTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*
*     SUBROUTINE DTPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*
*     SUBROUTINE DGER  ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE DSYR  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*
*     SUBROUTINE DSPR  ( UPLO, N, ALPHA, X, INCX, AP )
*
*     SUBROUTINE DSYR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE DSPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*
*     See:
*
*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J..
*        An  extended  set of Fortran  Basic Linear Algebra Subprograms.
*
*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics
*        and  Computer Science  Division,  Argonne  National Laboratory,
*        9700 South Cass Avenue, Argonne, Illinois 60439, US.
*
*        Or
*
*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms
*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford
*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st
*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA.
*
************************************************************************
*
X      SUBROUTINE DGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry with BETA non-zero, the incremented array Y
*           must contain the vector y. On exit, Y is overwritten by the
*           updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ONE         , ZERO
X      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DGEMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  DO 50, I = 1, M
X                     Y( I ) = Y( I ) + TEMP*A( I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  DO 70, I = 1, M
X                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 100, J = 1, N
X               TEMP = ZERO
X               DO 90, I = 1, M
X                  TEMP = TEMP + A( I, J )*X( I )
X   90          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  100       CONTINUE
X         ELSE
X            DO 120, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               DO 110, I = 1, M
X                  TEMP = TEMP + A( I, J )*X( IX )
X                  IX   = IX   + INCX
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DGEMV .
*
X      END
SHAR_EOF
chmod 0664 dgemv.f ||
echo 'restore of dgemv.f failed'
Wc_c="`wc -c < 'dgemv.f'`"
test 9630 -eq "$Wc_c" ||
	echo 'dgemv.f: original size 9630, current size' "$Wc_c"
fi
# ============= dsbmv.f ==============
if test -f 'dsbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dsbmv.f (File already exists)'
else
echo 'x - extracting dsbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dsbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE DSBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA, BETA
X      INTEGER            INCX, INCY, K, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DSBMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n symmetric band matrix, with k super-diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the band matrix A is being supplied as
*           follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  being supplied.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  being supplied.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry, K specifies the number of super-diagonals of the
*           matrix A. K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the symmetric matrix, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer the upper
*           triangular part of a symmetric band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the symmetric matrix, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer the lower
*           triangular part of a symmetric band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ONE         , ZERO
X      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KPLUS1, KX, KY, L
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( K.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array A
*     are accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when upper triangle of A is stored.
*
X         KPLUS1 = K + 1
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               L     = KPLUS1 - J
X               DO 50, I = MAX( 1, J - K ), J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + A( L + I, J )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*A( KPLUS1, J ) + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               L     = KPLUS1 - J
X               DO 70, I = MAX( 1, J - K ), J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + A( L + I, J )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*A( KPLUS1, J ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               IF( J.GT.K )THEN
X                  KX = KX + INCX
X                  KY = KY + INCY
X               END IF
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when lower triangle of A is stored.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J )       + TEMP1*A( 1, J )
X               L      = 1            - J
X               DO 90, I = J + 1, MIN( N, J + K )
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + A( L + I, J )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY )       + TEMP1*A( 1, J )
X               L       = 1             - J
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, MIN( N, J + K )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + A( L + I, J )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSBMV .
*
X      END
SHAR_EOF
chmod 0664 dsbmv.f ||
echo 'restore of dsbmv.f failed'
Wc_c="`wc -c < 'dsbmv.f'`"
test 9910 -eq "$Wc_c" ||
	echo 'dsbmv.f: original size 9910, current size' "$Wc_c"
fi
# ============= dspmv.f ==============
if test -f 'dspmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dspmv.f (File already exists)'
else
echo 'x - extracting dspmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dspmv.f' &&
*
************************************************************************
*
X      SUBROUTINE DSPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA, BETA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DSPMV  performs the matrix-vector operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n symmetric matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  AP     - DOUBLE PRECISION array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ONE         , ZERO
X      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 6
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when AP contains the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               K     = KK
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + AP( K )*X( I )
X                  K      = K      + 1
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*AP( KK + J - 1 ) + ALPHA*TEMP2
X               KK     = KK     + J
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, K = KK, KK + J - 2
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + AP( K )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*AP( KK + J - 1 ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + J
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when AP contains the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J )       + TEMP1*AP( KK )
X               K      = KK           + 1
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + AP( K )*X( I )
X                  K      = K      + 1
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X               KK     = KK     + ( N - J + 1 )
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY )       + TEMP1*AP( KK )
X               IX      = JX
X               IY      = JY
X               DO 110, K = KK + 1, KK + N - J
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + AP( K )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + ( N - J + 1 )
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSPMV .
*
X      END
SHAR_EOF
chmod 0664 dspmv.f ||
echo 'restore of dspmv.f failed'
Wc_c="`wc -c < 'dspmv.f'`"
test 8277 -eq "$Wc_c" ||
	echo 'dspmv.f: original size 8277, current size' "$Wc_c"
fi
# ============= dsymv.f ==============
if test -f 'dsymv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dsymv.f (File already exists)'
else
echo 'x - extracting dsymv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dsymv.f' &&
*
************************************************************************
*
X      SUBROUTINE DSYMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DSYMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n symmetric matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the symmetric matrix and the strictly
*           lower triangular part of A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the symmetric matrix and the strictly
*           upper triangular part of A is not referenced.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ONE         , ZERO
X      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 5
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 10
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSYMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when A is stored in upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + A( I, J )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*A( J, J ) + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, I = 1, J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + A( I, J )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*A( J, J ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when A is stored in lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J )       + TEMP1*A( J, J )
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + A( I, J )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY )       + TEMP1*A( J, J )
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, N
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + A( I, J )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSYMV .
*
X      END
SHAR_EOF
chmod 0664 dsymv.f ||
echo 'restore of dsymv.f failed'
Wc_c="`wc -c < 'dsymv.f'`"
test 8149 -eq "$Wc_c" ||
	echo 'dsymv.f: original size 8149, current size' "$Wc_c"
fi
# ============= dtbmv.f ==============
if test -f 'dtbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dtbmv.f (File already exists)'
else
echo 'x - extracting dtbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dtbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE DTBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTBMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DTBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX   too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*         Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = KPLUS1 - J
X                     DO 10, I = MAX( 1, J - K ), J - 1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( KPLUS1, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = KPLUS1  - J
X                     DO 30, I = MAX( 1, J - K ), J - 1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( KPLUS1, J )
X                  END IF
X                  JX = JX + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = 1      - J
X                     DO 50, I = MIN( N, J + K ), J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( 1, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = 1       - J
X                     DO 70, I = MIN( N, J + K ), J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( 1, J )
X                  END IF
X                  JX = JX - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( KPLUS1, J )
X                  DO 90, I = J - 1, MAX( 1, J - K ), -1
X                     TEMP = TEMP + A( L + I, J )*X( I )
X   90             CONTINUE
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 120, J = N, 1, -1
X                  TEMP = X( JX )
X                  KX   = KX      - INCX
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( KPLUS1, J )
X                  DO 110, I = J - 1, MAX( 1, J - K ), -1
X                     TEMP = TEMP + A( L + I, J )*X( IX )
X                     IX   = IX   - INCX
X  110             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = 1, N
X                  TEMP = X( J )
X                  L    = 1      - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( 1, J )
X                  DO 130, I = J + 1, MIN( N, J + K )
X                     TEMP = TEMP + A( L + I, J )*X( I )
X  130             CONTINUE
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               JX = KX
X               DO 160, J = 1, N
X                  TEMP = X( JX )
X                  KX   = KX      + INCX
X                  IX   = KX
X                  L    = 1       - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( 1, J )
X                  DO 150, I = J + 1, MIN( N, J + K )
X                     TEMP = TEMP + A( L + I, J )*X( IX )
X                     IX   = IX   + INCX
X  150             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of DTBMV .
*
X      END
SHAR_EOF
chmod 0664 dtbmv.f ||
echo 'restore of dtbmv.f failed'
Wc_c="`wc -c < 'dtbmv.f'`"
test 11432 -eq "$Wc_c" ||
	echo 'dtbmv.f: original size 11432, current size' "$Wc_c"
fi
# ============= dtpmv.f ==============
if test -f 'dtpmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dtpmv.f (File already exists)'
else
echo 'x - extracting dtpmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dtpmv.f' &&
*
************************************************************************
*
X      SUBROUTINE DTPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTPMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - DOUBLE PRECISION array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DTPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x:= A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK =1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      + 1
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK + J - 1 )
X                  END IF
X                  KK = KK + J
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, K = KK, KK + J - 2
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK + J - 1 )
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      - 1
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK - N + J )
X                  END IF
X                  KK = KK - ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK - N + J )
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  K = KK - 1
X                  DO 90, I = J - 1, 1, -1
X                     TEMP = TEMP + AP( K )*X( I )
X                     K    = K    - 1
X   90             CONTINUE
X                  X( J ) = TEMP
X                  KK     = KK   - J
X  100          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 120, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  DO 110, K = KK - 1, KK - J + 1, -1
X                     IX   = IX   - INCX
X                     TEMP = TEMP + AP( K )*X( IX )
X  110             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - J
X  120          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = 1, N
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  K = KK + 1
X                  DO 130, I = J + 1, N
X                     TEMP = TEMP + AP( K )*X( I )
X                     K    = K    + 1
X  130             CONTINUE
X                  X( J ) = TEMP
X                  KK     = KK   + ( N - J + 1 )
X  140          CONTINUE
X            ELSE
X               JX = KX
X               DO 160, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  DO 150, K = KK + 1, KK + N - J
X                     IX   = IX   + INCX
X                     TEMP = TEMP + AP( K )*X( IX )
X  150             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + ( N - J + 1 )
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of DTPMV .
*
X      END
SHAR_EOF
chmod 0664 dtpmv.f ||
echo 'restore of dtpmv.f failed'
Wc_c="`wc -c < 'dtpmv.f'`"
test 9521 -eq "$Wc_c" ||
	echo 'dtpmv.f: original size 9521, current size' "$Wc_c"
fi
# ============= dtrmv.f ==============
if test -f 'dtrmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dtrmv.f (File already exists)'
else
echo 'x - extracting dtrmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dtrmv.f' &&
*
************************************************************************
*
X      SUBROUTINE DTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTRMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DTRMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, I = 1, J - 1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, I = N, J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 90, I = J - 1, 1, -1
X                     TEMP = TEMP + A( I, J )*X( I )
X   90             CONTINUE
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 120, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 110, I = J - 1, 1, -1
X                     IX   = IX   - INCX
X                     TEMP = TEMP + A( I, J )*X( IX )
X  110             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = 1, N
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 130, I = J + 1, N
X                     TEMP = TEMP + A( I, J )*X( I )
X  130             CONTINUE
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               JX = KX
X               DO 160, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 150, I = J + 1, N
X                     IX   = IX   + INCX
X                     TEMP = TEMP + A( I, J )*X( IX )
X  150             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of DTRMV .
*
X      END
SHAR_EOF
chmod 0664 dtrmv.f ||
echo 'restore of dtrmv.f failed'
Wc_c="`wc -c < 'dtrmv.f'`"
test 8939 -eq "$Wc_c" ||
	echo 'dtrmv.f: original size 8939, current size' "$Wc_c"
fi
# ============= sgbmv.f ==============
if test -f 'sgbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping sgbmv.f (File already exists)'
else
echo 'x - extracting sgbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'sgbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE SGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      REAL               ALPHA, BETA
X      INTEGER            INCX, INCY, KL, KU, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SGBMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n band matrix, with kl sub-diagonals and ku super-diagonals.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  KL     - INTEGER.
*           On entry, KL specifies the number of sub-diagonals of the
*           matrix A. KL must satisfy  0 .le. KL.
*           Unchanged on exit.
*
*  KU     - INTEGER.
*           On entry, KU specifies the number of super-diagonals of the
*           matrix A. KU must satisfy  0 .le. KU.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry, the leading ( kl + ku + 1 ) by n part of the
*           array A must contain the matrix of coefficients, supplied
*           column by column, with the leading diagonal of the matrix in
*           row ( ku + 1 ) of the array, the first super-diagonal
*           starting at position 2 in row ku, the first sub-diagonal
*           starting at position 1 in row ( ku + 2 ), and so on.
*           Elements in the array A that do not correspond to elements
*           in the band matrix (such as the top left ku by ku triangle)
*           are not referenced.
*           The following program segment will transfer a band matrix
*           from conventional full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    K = KU + 1 - J
*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
*                       A( K + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( kl + ku + 1 ).
*           Unchanged on exit.
*
*  X      - REAL             array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - REAL            .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - REAL             array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*     .. Parameters ..
X      REAL               ONE         , ZERO
X      PARAMETER        ( ONE = 1.0E+0, ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KUP1, KX, KY,
X     $                   LENX, LENY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( KL.LT.0 )THEN
X         INFO = 4
X      ELSE IF( KU.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( KL + KU + 1 ) )THEN
X         INFO = 8
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 10
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 13
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SGBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the band part of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KUP1 = KU + 1
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  K    = KUP1 - J
X                  DO 50, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( I ) = Y( I ) + TEMP*A( K + I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  K    = KUP1 - J
X                  DO 70, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( IY ) = Y( IY ) + TEMP*A( K + I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               IF( J.GT.KU )
X     $            KY = KY + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 100, J = 1, N
X               TEMP = ZERO
X               K    = KUP1 - J
X               DO 90, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                  TEMP = TEMP + A( K + I, J )*X( I )
X   90          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  100       CONTINUE
X         ELSE
X            DO 120, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               K    = KUP1 - J
X               DO 110, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                  TEMP = TEMP + A( K + I, J )*X( IX )
X                  IX   = IX   + INCX
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X               IF( J.GT.KU )
X     $            KX = KX + INCX
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SGBMV .
*
X      END
SHAR_EOF
chmod 0664 sgbmv.f ||
echo 'restore of sgbmv.f failed'
Wc_c="`wc -c < 'sgbmv.f'`"
test 9372 -eq "$Wc_c" ||
	echo 'sgbmv.f: original size 9372, current size' "$Wc_c"
fi
# ============= sgemv.f ==============
if test -f 'sgemv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping sgemv.f (File already exists)'
else
echo 'x - extracting sgemv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'sgemv.f' &&
X      SUBROUTINE SGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      REAL               ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*  X      - REAL             array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - REAL            .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - REAL             array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry with BETA non-zero, the incremented array Y
*           must contain the vector y. On exit, Y is overwritten by the
*           updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ONE         , ZERO
X      PARAMETER        ( ONE = 1.0E+0, ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SGEMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  DO 50, I = 1, M
X                     Y( I ) = Y( I ) + TEMP*A( I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  DO 70, I = 1, M
X                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 100, J = 1, N
X               TEMP = ZERO
X               DO 90, I = 1, M
X                  TEMP = TEMP + A( I, J )*X( I )
X   90          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  100       CONTINUE
X         ELSE
X            DO 120, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               DO 110, I = 1, M
X                  TEMP = TEMP + A( I, J )*X( IX )
X                  IX   = IX   + INCX
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SGEMV .
*
X      END
SHAR_EOF
chmod 0664 sgemv.f ||
echo 'restore of sgemv.f failed'
Wc_c="`wc -c < 'sgemv.f'`"
test 7481 -eq "$Wc_c" ||
	echo 'sgemv.f: original size 7481, current size' "$Wc_c"
fi
# ============= ssbmv.f ==============
if test -f 'ssbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ssbmv.f (File already exists)'
else
echo 'x - extracting ssbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ssbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE SSBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      REAL               ALPHA, BETA
X      INTEGER            INCX, INCY, K, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SSBMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n symmetric band matrix, with k super-diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the band matrix A is being supplied as
*           follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  being supplied.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  being supplied.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry, K specifies the number of super-diagonals of the
*           matrix A. K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the symmetric matrix, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer the upper
*           triangular part of a symmetric band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the symmetric matrix, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer the lower
*           triangular part of a symmetric band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - REAL             array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - REAL            .
*           On entry, BETA specifies the scalar beta.
*           Unchanged on exit.
*
*  Y      - REAL             array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ONE         , ZERO
X      PARAMETER        ( ONE = 1.0E+0, ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KPLUS1, KX, KY, L
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( K.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array A
*     are accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when upper triangle of A is stored.
*
X         KPLUS1 = K + 1
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               L     = KPLUS1 - J
X               DO 50, I = MAX( 1, J - K ), J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + A( L + I, J )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*A( KPLUS1, J ) + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               L     = KPLUS1 - J
X               DO 70, I = MAX( 1, J - K ), J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + A( L + I, J )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*A( KPLUS1, J ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               IF( J.GT.K )THEN
X                  KX = KX + INCX
X                  KY = KY + INCY
X               END IF
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when lower triangle of A is stored.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J )       + TEMP1*A( 1, J )
X               L      = 1            - J
X               DO 90, I = J + 1, MIN( N, J + K )
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + A( L + I, J )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY )       + TEMP1*A( 1, J )
X               L       = 1             - J
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, MIN( N, J + K )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + A( L + I, J )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSBMV .
*
X      END
SHAR_EOF
chmod 0664 ssbmv.f ||
echo 'restore of ssbmv.f failed'
Wc_c="`wc -c < 'ssbmv.f'`"
test 9910 -eq "$Wc_c" ||
	echo 'ssbmv.f: original size 9910, current size' "$Wc_c"
fi
# ============= sspmv.f ==============
if test -f 'sspmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping sspmv.f (File already exists)'
else
echo 'x - extracting sspmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'sspmv.f' &&
*
************************************************************************
*
X      SUBROUTINE SSPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*     .. Scalar Arguments ..
X      REAL               ALPHA, BETA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SSPMV  performs the matrix-vector operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n symmetric matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  AP     - REAL             array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - REAL            .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ONE         , ZERO
X      PARAMETER        ( ONE = 1.0E+0, ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 6
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when AP contains the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               K     = KK
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + AP( K )*X( I )
X                  K      = K      + 1
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*AP( KK + J - 1 ) + ALPHA*TEMP2
X               KK     = KK     + J
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, K = KK, KK + J - 2
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + AP( K )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*AP( KK + J - 1 ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + J
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when AP contains the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J )       + TEMP1*AP( KK )
X               K      = KK           + 1
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + AP( K )*X( I )
X                  K      = K      + 1
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X               KK     = KK     + ( N - J + 1 )
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY )       + TEMP1*AP( KK )
X               IX      = JX
X               IY      = JY
X               DO 110, K = KK + 1, KK + N - J
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + AP( K )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + ( N - J + 1 )
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSPMV .
*
X      END
SHAR_EOF
chmod 0664 sspmv.f ||
echo 'restore of sspmv.f failed'
Wc_c="`wc -c < 'sspmv.f'`"
test 8277 -eq "$Wc_c" ||
	echo 'sspmv.f: original size 8277, current size' "$Wc_c"
fi
# ============= ssymv.f ==============
if test -f 'ssymv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ssymv.f (File already exists)'
else
echo 'x - extracting ssymv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ssymv.f' &&
*
************************************************************************
*
X      SUBROUTINE SSYMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      REAL               ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SSYMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n symmetric matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the symmetric matrix and the strictly
*           lower triangular part of A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the symmetric matrix and the strictly
*           upper triangular part of A is not referenced.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - REAL            .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ONE         , ZERO
X      PARAMETER        ( ONE = 1.0E+0, ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 5
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 10
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSYMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when A is stored in upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + A( I, J )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*A( J, J ) + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, I = 1, J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + A( I, J )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*A( J, J ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when A is stored in lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J )       + TEMP1*A( J, J )
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + A( I, J )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY )       + TEMP1*A( J, J )
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, N
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + A( I, J )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSYMV .
*
X      END
SHAR_EOF
chmod 0664 ssymv.f ||
echo 'restore of ssymv.f failed'
Wc_c="`wc -c < 'ssymv.f'`"
test 8149 -eq "$Wc_c" ||
	echo 'ssymv.f: original size 8149, current size' "$Wc_c"
fi
# ============= stbmv.f ==============
if test -f 'stbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping stbmv.f (File already exists)'
else
echo 'x - extracting stbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'stbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE STBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  STBMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'STBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX   too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*         Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = KPLUS1 - J
X                     DO 10, I = MAX( 1, J - K ), J - 1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( KPLUS1, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = KPLUS1  - J
X                     DO 30, I = MAX( 1, J - K ), J - 1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( KPLUS1, J )
X                  END IF
X                  JX = JX + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = 1      - J
X                     DO 50, I = MIN( N, J + K ), J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( 1, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = 1       - J
X                     DO 70, I = MIN( N, J + K ), J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( 1, J )
X                  END IF
X                  JX = JX - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( KPLUS1, J )
X                  DO 90, I = J - 1, MAX( 1, J - K ), -1
X                     TEMP = TEMP + A( L + I, J )*X( I )
X   90             CONTINUE
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 120, J = N, 1, -1
X                  TEMP = X( JX )
X                  KX   = KX      - INCX
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( KPLUS1, J )
X                  DO 110, I = J - 1, MAX( 1, J - K ), -1
X                     TEMP = TEMP + A( L + I, J )*X( IX )
X                     IX   = IX   - INCX
X  110             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = 1, N
X                  TEMP = X( J )
X                  L    = 1      - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( 1, J )
X                  DO 130, I = J + 1, MIN( N, J + K )
X                     TEMP = TEMP + A( L + I, J )*X( I )
X  130             CONTINUE
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               JX = KX
X               DO 160, J = 1, N
X                  TEMP = X( JX )
X                  KX   = KX      + INCX
X                  IX   = KX
X                  L    = 1       - J
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( 1, J )
X                  DO 150, I = J + 1, MIN( N, J + K )
X                     TEMP = TEMP + A( L + I, J )*X( IX )
X                     IX   = IX   + INCX
X  150             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of STBMV .
*
X      END
SHAR_EOF
chmod 0664 stbmv.f ||
echo 'restore of stbmv.f failed'
Wc_c="`wc -c < 'stbmv.f'`"
test 11432 -eq "$Wc_c" ||
	echo 'stbmv.f: original size 11432, current size' "$Wc_c"
fi
# ============= stpmv.f ==============
if test -f 'stpmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping stpmv.f (File already exists)'
else
echo 'x - extracting stpmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'stpmv.f' &&
*
************************************************************************
*
X      SUBROUTINE STPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      REAL               AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  STPMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - REAL             array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'STPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x:= A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK =1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      + 1
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK + J - 1 )
X                  END IF
X                  KK = KK + J
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, K = KK, KK + J - 2
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK + J - 1 )
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      - 1
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK - N + J )
X                  END IF
X                  KK = KK - ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK - N + J )
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  K = KK - 1
X                  DO 90, I = J - 1, 1, -1
X                     TEMP = TEMP + AP( K )*X( I )
X                     K    = K    - 1
X   90             CONTINUE
X                  X( J ) = TEMP
X                  KK     = KK   - J
X  100          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 120, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  DO 110, K = KK - 1, KK - J + 1, -1
X                     IX   = IX   - INCX
X                     TEMP = TEMP + AP( K )*X( IX )
X  110             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - J
X  120          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = 1, N
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  K = KK + 1
X                  DO 130, I = J + 1, N
X                     TEMP = TEMP + AP( K )*X( I )
X                     K    = K    + 1
X  130             CONTINUE
X                  X( J ) = TEMP
X                  KK     = KK   + ( N - J + 1 )
X  140          CONTINUE
X            ELSE
X               JX = KX
X               DO 160, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*AP( KK )
X                  DO 150, K = KK + 1, KK + N - J
X                     IX   = IX   + INCX
X                     TEMP = TEMP + AP( K )*X( IX )
X  150             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + ( N - J + 1 )
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of STPMV .
*
X      END
SHAR_EOF
chmod 0664 stpmv.f ||
echo 'restore of stpmv.f failed'
Wc_c="`wc -c < 'stpmv.f'`"
test 9521 -eq "$Wc_c" ||
	echo 'stpmv.f: original size 9521, current size' "$Wc_c"
fi
# ============= strmv.f ==============
if test -f 'strmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping strmv.f (File already exists)'
else
echo 'x - extracting strmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'strmv.f' &&
*
************************************************************************
*
X      SUBROUTINE STRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  STRMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'STRMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, I = 1, J - 1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, I = N, J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 90, I = J - 1, 1, -1
X                     TEMP = TEMP + A( I, J )*X( I )
X   90             CONTINUE
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 120, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 110, I = J - 1, 1, -1
X                     IX   = IX   - INCX
X                     TEMP = TEMP + A( I, J )*X( IX )
X  110             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = 1, N
X                  TEMP = X( J )
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 130, I = J + 1, N
X                     TEMP = TEMP + A( I, J )*X( I )
X  130             CONTINUE
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               JX = KX
X               DO 160, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOUNIT )
X     $               TEMP = TEMP*A( J, J )
X                  DO 150, I = J + 1, N
X                     IX   = IX   + INCX
X                     TEMP = TEMP + A( I, J )*X( IX )
X  150             CONTINUE
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of STRMV .
*
X      END
SHAR_EOF
chmod 0664 strmv.f ||
echo 'restore of strmv.f failed'
Wc_c="`wc -c < 'strmv.f'`"
test 8939 -eq "$Wc_c" ||
	echo 'strmv.f: original size 8939, current size' "$Wc_c"
fi
# ============= zgbmv.f ==============
if test -f 'zgbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zgbmv.f (File already exists)'
else
echo 'x - extracting zgbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zgbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA, BETA
X      INTEGER            INCX, INCY, KL, KU, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZGBMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
*
*     y := alpha*conjg( A' )*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n band matrix, with kl sub-diagonals and ku super-diagonals.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  KL     - INTEGER.
*           On entry, KL specifies the number of sub-diagonals of the
*           matrix A. KL must satisfy  0 .le. KL.
*           Unchanged on exit.
*
*  KU     - INTEGER.
*           On entry, KU specifies the number of super-diagonals of the
*           matrix A. KU must satisfy  0 .le. KU.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry, the leading ( kl + ku + 1 ) by n part of the
*           array A must contain the matrix of coefficients, supplied
*           column by column, with the leading diagonal of the matrix in
*           row ( ku + 1 ) of the array, the first super-diagonal
*           starting at position 2 in row ku, the first sub-diagonal
*           starting at position 1 in row ( ku + 2 ), and so on.
*           Elements in the array A that do not correspond to elements
*           in the band matrix (such as the top left ku by ku triangle)
*           are not referenced.
*           The following program segment will transfer a band matrix
*           from conventional full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    K = KU + 1 - J
*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
*                       A( K + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( kl + ku + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX*16      .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ONE
X      PARAMETER        ( ONE  = ( 1.0D+0, 0.0D+0 ) )
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KUP1, KX, KY,
X     $                   LENX, LENY
X      LOGICAL            NOCONJ
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( KL.LT.0 )THEN
X         INFO = 4
X      ELSE IF( KU.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( KL + KU + 1 ) )THEN
X         INFO = 8
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 10
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 13
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZGBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the band part of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KUP1 = KU + 1
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  K    = KUP1 - J
X                  DO 50, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( I ) = Y( I ) + TEMP*A( K + I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  K    = KUP1 - J
X                  DO 70, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     Y( IY ) = Y( IY ) + TEMP*A( K + I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               IF( J.GT.KU )
X     $            KY = KY + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 110, J = 1, N
X               TEMP = ZERO
X               K    = KUP1 - J
X               IF( NOCONJ )THEN
X                  DO 90, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + A( K + I, J )*X( I )
X   90             CONTINUE
X               ELSE
X                  DO 100, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + DCONJG( A( K + I, J ) )*X( I )
X  100             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  110       CONTINUE
X         ELSE
X            DO 140, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               K    = KUP1 - J
X               IF( NOCONJ )THEN
X                  DO 120, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + A( K + I, J )*X( IX )
X                     IX   = IX   + INCX
X  120             CONTINUE
X               ELSE
X                  DO 130, I = MAX( 1, J - KU ), MIN( M, J + KL )
X                     TEMP = TEMP + DCONJG( A( K + I, J ) )*X( IX )
X                     IX   = IX   + INCX
X  130             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X               IF( J.GT.KU )
X     $            KX = KX + INCX
X  140       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZGBMV .
*
X      END
SHAR_EOF
chmod 0664 zgbmv.f ||
echo 'restore of zgbmv.f failed'
Wc_c="`wc -c < 'zgbmv.f'`"
test 10136 -eq "$Wc_c" ||
	echo 'zgbmv.f: original size 10136, current size' "$Wc_c"
fi
# ============= zgemv.f ==============
if test -f 'zgemv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zgemv.f (File already exists)'
else
echo 'x - extracting zgemv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zgemv.f' &&
*
************************************************************************
*
*     File of the COMPLEX*16       Level-2 BLAS.
*     ==========================================
*
*     SUBROUTINE ZGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE ZGBMV ( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE ZHEMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE ZHBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
*    $                   BETA, Y, INCY )
*
*     SUBROUTINE ZHPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*
*     SUBROUTINE ZTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*
*     SUBROUTINE ZTBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*
*     SUBROUTINE ZTPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*
*     SUBROUTINE ZTRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*
*     SUBROUTINE ZTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*
*     SUBROUTINE ZTPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*
*     SUBROUTINE ZGERU ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE ZGERC ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE ZHER  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*
*     SUBROUTINE ZHPR  ( UPLO, N, ALPHA, X, INCX, AP )
*
*     SUBROUTINE ZHER2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*
*     SUBROUTINE ZHPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*
*     See:
*
*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J..
*        An  extended  set of Fortran  Basic Linear Algebra Subprograms.
*
*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics
*        and  Computer Science  Division,  Argonne  National Laboratory,
*        9700 South Cass Avenue, Argonne, Illinois 60439, US.
*
*        Or
*
*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms
*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford
*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st
*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA.
*
************************************************************************
*
X      SUBROUTINE ZGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, M, N
X      CHARACTER*1        TRANS
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
*
*     y := alpha*conjg( A' )*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX*16      .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry with BETA non-zero, the incremented array Y
*           must contain the vector y. On exit, Y is overwritten by the
*           updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ONE
X      PARAMETER        ( ONE  = ( 1.0D+0, 0.0D+0 ) )
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
X      LOGICAL            NOCONJ
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 1
X      ELSE IF( M.LT.0 )THEN
X         INFO = 2
X      ELSE IF( N.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZGEMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
X     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
X         LENX = N
X         LENY = M
X      ELSE
X         LENX = M
X         LENY = N
X      END IF
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( LENX - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( LENY - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, LENY
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, LENY
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, LENY
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, LENY
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
X         JX = KX
X         IF( INCY.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  DO 50, I = 1, M
X                     Y( I ) = Y( I ) + TEMP*A( I, J )
X   50             CONTINUE
X               END IF
X               JX = JX + INCX
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IY   = KY
X                  DO 70, I = 1, M
X                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y.
*
X         JY = KY
X         IF( INCX.EQ.1 )THEN
X            DO 110, J = 1, N
X               TEMP = ZERO
X               IF( NOCONJ )THEN
X                  DO 90, I = 1, M
X                     TEMP = TEMP + A( I, J )*X( I )
X   90             CONTINUE
X               ELSE
X                  DO 100, I = 1, M
X                     TEMP = TEMP + DCONJG( A( I, J ) )*X( I )
X  100             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  110       CONTINUE
X         ELSE
X            DO 140, J = 1, N
X               TEMP = ZERO
X               IX   = KX
X               IF( NOCONJ )THEN
X                  DO 120, I = 1, M
X                     TEMP = TEMP + A( I, J )*X( IX )
X                     IX   = IX   + INCX
X  120             CONTINUE
X               ELSE
X                  DO 130, I = 1, M
X                     TEMP = TEMP + DCONJG( A( I, J ) )*X( IX )
X                     IX   = IX   + INCX
X  130             CONTINUE
X               END IF
X               Y( JY ) = Y( JY ) + ALPHA*TEMP
X               JY      = JY      + INCY
X  140       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZGEMV .
*
X      END
SHAR_EOF
chmod 0664 zgemv.f ||
echo 'restore of zgemv.f failed'
Wc_c="`wc -c < 'zgemv.f'`"
test 10387 -eq "$Wc_c" ||
	echo 'zgemv.f: original size 10387, current size' "$Wc_c"
fi
# ============= zhbmv.f ==============
if test -f 'zhbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zhbmv.f (File already exists)'
else
echo 'x - extracting zhbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zhbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHBMV ( UPLO, N, K, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA, BETA
X      INTEGER            INCX, INCY, K, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHBMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n hermitian band matrix, with k super-diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the band matrix A is being supplied as
*           follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  being supplied.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  being supplied.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry, K specifies the number of super-diagonals of the
*           matrix A. K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the hermitian matrix, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer the upper
*           triangular part of a hermitian band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the hermitian matrix, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer the lower
*           triangular part of a hermitian band matrix from conventional
*           full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that the imaginary parts of the diagonal elements need
*           not be set and are assumed to be zero.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX*16      .
*           On entry, BETA specifies the scalar beta.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the
*           vector y. On exit, Y is overwritten by the updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ONE
X      PARAMETER        ( ONE  = ( 1.0D+0, 0.0D+0 ) )
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KPLUS1, KX, KY, L
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, MIN, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( K.LT.0 )THEN
X         INFO = 3
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 11
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array A
*     are accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when upper triangle of A is stored.
*
X         KPLUS1 = K + 1
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               L     = KPLUS1 - J
X               DO 50, I = MAX( 1, J - K ), J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + DCONJG( A( L + I, J ) )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*DBLE( A( KPLUS1, J ) )
X     $                         + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               L     = KPLUS1 - J
X               DO 70, I = MAX( 1, J - K ), J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + DCONJG( A( L + I, J ) )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*DBLE( A( KPLUS1, J ) )
X     $                           + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               IF( J.GT.K )THEN
X                  KX = KX + INCX
X                  KY = KY + INCY
X               END IF
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when lower triangle of A is stored.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J ) + TEMP1*DBLE( A( 1, J ) )
X               L      = 1      - J
X               DO 90, I = J + 1, MIN( N, J + K )
X                  Y( I ) = Y( I ) + TEMP1*A( L + I, J )
X                  TEMP2  = TEMP2  + DCONJG( A( L + I, J ) )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY ) + TEMP1*DBLE( A( 1, J ) )
X               L       = 1       - J
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, MIN( N, J + K )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( L + I, J )
X                  TEMP2   = TEMP2   + DCONJG( A( L + I, J ) )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHBMV .
*
X      END
SHAR_EOF
chmod 0664 zhbmv.f ||
echo 'restore of zhbmv.f failed'
Wc_c="`wc -c < 'zhbmv.f'`"
test 10225 -eq "$Wc_c" ||
	echo 'zhbmv.f: original size 10225, current size' "$Wc_c"
fi
# ============= zhemv.f ==============
if test -f 'zhemv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zhemv.f (File already exists)'
else
echo 'x - extracting zhemv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zhemv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHEMV ( UPLO, N, ALPHA, A, LDA, X, INCX,
X     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA, BETA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHEMV  performs the matrix-vector  operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n hermitian matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the hermitian matrix and the strictly
*           lower triangular part of A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the hermitian matrix and the strictly
*           upper triangular part of A is not referenced.
*           Note that the imaginary parts of the diagonal elements need
*           not be set and are assumed to be zero.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX*16      .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ONE
X      PARAMETER        ( ONE  = ( 1.0D+0, 0.0D+0 ) )
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 5
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 10
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHEMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when A is stored in upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + DCONJG( A( I, J ) )*X( I )
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*DBLE( A( J, J ) ) + ALPHA*TEMP2
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, I = 1, J - 1
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + DCONJG( A( I, J ) )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*DBLE( A( J, J ) ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when A is stored in lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J ) + TEMP1*DBLE( A( J, J ) )
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*A( I, J )
X                  TEMP2  = TEMP2  + DCONJG( A( I, J ) )*X( I )
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY ) + TEMP1*DBLE( A( J, J ) )
X               IX      = JX
X               IY      = JY
X               DO 110, I = J + 1, N
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*A( I, J )
X                  TEMP2   = TEMP2   + DCONJG( A( I, J ) )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHEMV .
*
X      END
SHAR_EOF
chmod 0664 zhemv.f ||
echo 'restore of zhemv.f failed'
Wc_c="`wc -c < 'zhemv.f'`"
test 8412 -eq "$Wc_c" ||
	echo 'zhemv.f: original size 8412, current size' "$Wc_c"
fi
# ============= zhpmv.f ==============
if test -f 'zhpmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zhpmv.f (File already exists)'
else
echo 'x - extracting zhpmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zhpmv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHPMV ( UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA, BETA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHPMV  performs the matrix-vector operation
*
*     y := alpha*A*x + beta*y,
*
*  where alpha and beta are scalars, x and y are n element vectors and
*  A is an n by n hermitian matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  AP     - COMPLEX*16       array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on.
*           Note that the imaginary parts of the diagonal elements need
*           not be set and are assumed to be zero.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - COMPLEX*16      .
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y. On exit, Y is overwritten by the updated
*           vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ONE
X      PARAMETER        ( ONE  = ( 1.0D+0, 0.0D+0 ) )
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 6
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
X     $   RETURN
*
*     Set up the start points in  X  and  Y.
*
X      IF( INCX.GT.0 )THEN
X         KX = 1
X      ELSE
X         KX = 1 - ( N - 1 )*INCX
X      END IF
X      IF( INCY.GT.0 )THEN
X         KY = 1
X      ELSE
X         KY = 1 - ( N - 1 )*INCY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
*     First form  y := beta*y.
*
X      IF( BETA.NE.ONE )THEN
X         IF( INCY.EQ.1 )THEN
X            IF( BETA.EQ.ZERO )THEN
X               DO 10, I = 1, N
X                  Y( I ) = ZERO
X   10          CONTINUE
X            ELSE
X               DO 20, I = 1, N
X                  Y( I ) = BETA*Y( I )
X   20          CONTINUE
X            END IF
X         ELSE
X            IY = KY
X            IF( BETA.EQ.ZERO )THEN
X               DO 30, I = 1, N
X                  Y( IY ) = ZERO
X                  IY      = IY   + INCY
X   30          CONTINUE
X            ELSE
X               DO 40, I = 1, N
X                  Y( IY ) = BETA*Y( IY )
X                  IY      = IY           + INCY
X   40          CONTINUE
X            END IF
X         END IF
X      END IF
X      IF( ALPHA.EQ.ZERO )
X     $   RETURN
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  y  when AP contains the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               TEMP1 = ALPHA*X( J )
X               TEMP2 = ZERO
X               K     = KK
X               DO 50, I = 1, J - 1
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + DCONJG( AP( K ) )*X( I )
X                  K      = K      + 1
X   50          CONTINUE
X               Y( J ) = Y( J ) + TEMP1*DBLE( AP( KK + J - 1 ) )
X     $                         + ALPHA*TEMP2
X               KK     = KK     + J
X   60       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 80, J = 1, N
X               TEMP1 = ALPHA*X( JX )
X               TEMP2 = ZERO
X               IX    = KX
X               IY    = KY
X               DO 70, K = KK, KK + J - 2
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + DCONJG( AP( K ) )*X( IX )
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X   70          CONTINUE
X               Y( JY ) = Y( JY ) + TEMP1*DBLE( AP( KK + J - 1 ) )
X     $                           + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + J
X   80       CONTINUE
X         END IF
X      ELSE
*
*        Form  y  when AP contains the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 100, J = 1, N
X               TEMP1  = ALPHA*X( J )
X               TEMP2  = ZERO
X               Y( J ) = Y( J ) + TEMP1*DBLE( AP( KK ) )
X               K      = KK     + 1
X               DO 90, I = J + 1, N
X                  Y( I ) = Y( I ) + TEMP1*AP( K )
X                  TEMP2  = TEMP2  + DCONJG( AP( K ) )*X( I )
X                  K      = K      + 1
X   90          CONTINUE
X               Y( J ) = Y( J ) + ALPHA*TEMP2
X               KK     = KK     + ( N - J + 1 )
X  100       CONTINUE
X         ELSE
X            JX = KX
X            JY = KY
X            DO 120, J = 1, N
X               TEMP1   = ALPHA*X( JX )
X               TEMP2   = ZERO
X               Y( JY ) = Y( JY ) + TEMP1*DBLE( AP( KK ) )
X               IX      = JX
X               IY      = JY
X               DO 110, K = KK + 1, KK + N - J
X                  IX      = IX      + INCX
X                  IY      = IY      + INCY
X                  Y( IY ) = Y( IY ) + TEMP1*AP( K )
X                  TEMP2   = TEMP2   + DCONJG( AP( K ) )*X( IX )
X  110          CONTINUE
X               Y( JY ) = Y( JY ) + ALPHA*TEMP2
X               JX      = JX      + INCX
X               JY      = JY      + INCY
X               KK      = KK      + ( N - J + 1 )
X  120       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHPMV .
*
X      END
SHAR_EOF
chmod 0664 zhpmv.f ||
echo 'restore of zhpmv.f failed'
Wc_c="`wc -c < 'zhpmv.f'`"
test 8654 -eq "$Wc_c" ||
	echo 'zhpmv.f: original size 8654, current size' "$Wc_c"
fi
# ============= ztbmv.f ==============
if test -f 'ztbmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ztbmv.f (File already exists)'
else
echo 'x - extracting ztbmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ztbmv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZTBMV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZTBMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZTBMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX   too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*         Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = KPLUS1 - J
X                     DO 10, I = MAX( 1, J - K ), J - 1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( KPLUS1, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = KPLUS1  - J
X                     DO 30, I = MAX( 1, J - K ), J - 1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( KPLUS1, J )
X                  END IF
X                  JX = JX + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     L    = 1      - J
X                     DO 50, I = MIN( N, J + K ), J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( L + I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( 1, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     L    = 1       - J
X                     DO 70, I = MIN( N, J + K ), J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( 1, J )
X                  END IF
X                  JX = JX - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x  or  x := conjg( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( KPLUS1, J )
X                     DO 90, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + A( L + I, J )*X( I )
X   90                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( KPLUS1, J ) )
X                     DO 100, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + DCONJG( A( L + I, J ) )*X( I )
X  100                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 140, J = N, 1, -1
X                  TEMP = X( JX )
X                  KX   = KX      - INCX
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( KPLUS1, J )
X                     DO 120, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + A( L + I, J )*X( IX )
X                        IX   = IX   - INCX
X  120                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( KPLUS1, J ) )
X                     DO 130, I = J - 1, MAX( 1, J - K ), -1
X                        TEMP = TEMP + DCONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   - INCX
X  130                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = 1, N
X                  TEMP = X( J )
X                  L    = 1      - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( 1, J )
X                     DO 150, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + A( L + I, J )*X( I )
X  150                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( 1, J ) )
X                     DO 160, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + DCONJG( A( L + I, J ) )*X( I )
X  160                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               JX = KX
X               DO 200, J = 1, N
X                  TEMP = X( JX )
X                  KX   = KX      + INCX
X                  IX   = KX
X                  L    = 1       - J
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( 1, J )
X                     DO 180, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + A( L + I, J )*X( IX )
X                        IX   = IX   + INCX
X  180                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( 1, J ) )
X                     DO 190, I = J + 1, MIN( N, J + K )
X                        TEMP = TEMP + DCONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   + INCX
X  190                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZTBMV .
*
X      END
SHAR_EOF
chmod 0664 ztbmv.f ||
echo 'restore of ztbmv.f failed'
Wc_c="`wc -c < 'ztbmv.f'`"
test 13040 -eq "$Wc_c" ||
	echo 'ztbmv.f: original size 13040, current size' "$Wc_c"
fi
# ============= ztpmv.f ==============
if test -f 'ztpmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ztpmv.f (File already exists)'
else
echo 'x - extracting ztpmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ztpmv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZTPMV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX*16         AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZTPMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX*16       array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZTPMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x:= A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      + 1
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK + J - 1 )
X                  END IF
X                  KK = KK + J
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, K = KK, KK + J - 2
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK + J - 1 )
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     K    = KK
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*AP( K )
X                        K      = K      - 1
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*AP( KK - N + J )
X                  END IF
X                  KK = KK - ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        X( IX ) = X( IX ) + TEMP*AP( K )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*AP( KK - N + J )
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x  or  x := conjg( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = N, 1, -1
X                  TEMP = X( J )
X                  K    = KK     - 1
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 90, I = J - 1, 1, -1
X                        TEMP = TEMP + AP( K )*X( I )
X                        K    = K    - 1
X   90                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( AP( KK ) )
X                     DO 100, I = J - 1, 1, -1
X                        TEMP = TEMP + DCONJG( AP( K ) )*X( I )
X                        K    = K    - 1
X  100                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   - J
X  110          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 140, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 120, K = KK - 1, KK - J + 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + AP( K )*X( IX )
X  120                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( AP( KK ) )
X                     DO 130, K = KK - 1, KK - J + 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + DCONJG( AP( K ) )*X( IX )
X  130                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - J
X  140          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = 1, N
X                  TEMP = X( J )
X                  K    = KK     + 1
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 150, I = J + 1, N
X                        TEMP = TEMP + AP( K )*X( I )
X                        K    = K    + 1
X  150                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( AP( KK ) )
X                     DO 160, I = J + 1, N
X                        TEMP = TEMP + DCONJG( AP( K ) )*X( I )
X                        K    = K    + 1
X  160                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   + ( N - J + 1 )
X  170          CONTINUE
X            ELSE
X               JX = KX
X               DO 200, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*AP( KK )
X                     DO 180, K = KK + 1, KK + N - J
X                        IX   = IX   + INCX
X                        TEMP = TEMP + AP( K )*X( IX )
X  180                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( AP( KK ) )
X                     DO 190, K = KK + 1, KK + N - J
X                        IX   = IX   + INCX
X                        TEMP = TEMP + DCONJG( AP( K ) )*X( IX )
X  190                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + ( N - J + 1 )
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZTPMV .
*
X      END
SHAR_EOF
chmod 0664 ztpmv.f ||
echo 'restore of ztpmv.f failed'
Wc_c="`wc -c < 'ztpmv.f'`"
test 11212 -eq "$Wc_c" ||
	echo 'ztpmv.f: original size 11212, current size' "$Wc_c"
fi
# ============= ztrmv.f ==============
if test -f 'ztrmv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ztrmv.f (File already exists)'
else
echo 'x - extracting ztrmv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ztrmv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZTRMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZTRMV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := A*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 10, I = 1, J - 1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   10                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX
X               DO 40, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 30, I = 1, J - 1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      + INCX
X   30                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX + INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     TEMP = X( J )
X                     DO 50, I = N, J + 1, -1
X                        X( I ) = X( I ) + TEMP*A( I, J )
X   50                CONTINUE
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )*A( J, J )
X                  END IF
X   60          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 80, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     TEMP = X( JX )
X                     IX   = KX
X                     DO 70, I = N, J + 1, -1
X                        X( IX ) = X( IX ) + TEMP*A( I, J )
X                        IX      = IX      - INCX
X   70                CONTINUE
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )*A( J, J )
X                  END IF
X                  JX = JX - INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := A'*x  or  x := conjg( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 90, I = J - 1, 1, -1
X                        TEMP = TEMP + A( I, J )*X( I )
X   90                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( J, J ) )
X                     DO 100, I = J - 1, 1, -1
X                        TEMP = TEMP + DCONJG( A( I, J ) )*X( I )
X  100                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 140, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 120, I = J - 1, 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + A( I, J )*X( IX )
X  120                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( J, J ) )
X                     DO 130, I = J - 1, 1, -1
X                        IX   = IX   - INCX
X                        TEMP = TEMP + DCONJG( A( I, J ) )*X( IX )
X  130                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = 1, N
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 150, I = J + 1, N
X                        TEMP = TEMP + A( I, J )*X( I )
X  150                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( J, J ) )
X                     DO 160, I = J + 1, N
X                        TEMP = TEMP + DCONJG( A( I, J ) )*X( I )
X  160                CONTINUE
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               JX = KX
X               DO 200, J = 1, N
X                  TEMP = X( JX )
X                  IX   = JX
X                  IF( NOCONJ )THEN
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*A( J, J )
X                     DO 180, I = J + 1, N
X                        IX   = IX   + INCX
X                        TEMP = TEMP + A( I, J )*X( IX )
X  180                CONTINUE
X                  ELSE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP*DCONJG( A( J, J ) )
X                     DO 190, I = J + 1, N
X                        IX   = IX   + INCX
X                        TEMP = TEMP + DCONJG( A( I, J ) )*X( IX )
X  190                CONTINUE
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZTRMV .
*
X      END
SHAR_EOF
chmod 0664 ztrmv.f ||
echo 'restore of ztrmv.f failed'
Wc_c="`wc -c < 'ztrmv.f'`"
test 10465 -eq "$Wc_c" ||
	echo 'ztrmv.f: original size 10465, current size' "$Wc_c"
fi
# ============= ctbsv.f ==============
if test -f 'ctbsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ctbsv.f (File already exists)'
else
echo 'x - extracting ctbsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ctbsv.f' &&
*
************************************************************************
*
X      SUBROUTINE CTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CTBSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
*  diagonals.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CTBSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed by sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     L = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( KPLUS1, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, MAX( 1, J - K ), -1
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 40, J = N, 1, -1
X                  KX = KX - INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( KPLUS1, J )
X                     TEMP = X( JX )
X                     DO 30, I = J - 1, MAX( 1, J - K ), -1
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     L = 1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( 1, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, MIN( N, J + K )
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  KX = KX + INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = 1  - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( 1, J )
X                     TEMP = X( JX )
X                     DO 70, I = J + 1, MIN( N, J + K )
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x  or  x := inv( conjg( A') )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = 1, N
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  IF( NOCONJ )THEN
X                     DO 90, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - A( L + I, J )*X( I )
X   90                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( KPLUS1, J )
X                  ELSE
X                     DO 100, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - CONJG( A( L + I, J ) )*X( I )
X  100                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( KPLUS1, J ) )
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               JX = KX
X               DO 140, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  IF( NOCONJ )THEN
X                     DO 120, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - A( L + I, J )*X( IX )
X                        IX   = IX   + INCX
X  120                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( KPLUS1, J )
X                  ELSE
X                     DO 130, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - CONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   + INCX
X  130                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( KPLUS1, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = 1      - J
X                  IF( NOCONJ )THEN
X                     DO 150, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - A( L + I, J )*X( I )
X  150                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( 1, J )
X                  ELSE
X                     DO 160, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - CONJG( A( L + I, J ) )*X( I )
X  160                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( 1, J ) )
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 200, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = 1       - J
X                  IF( NOCONJ )THEN
X                     DO 180, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - A( L + I, J )*X( IX )
X                        IX   = IX   - INCX
X  180                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( 1, J )
X                  ELSE
X                     DO 190, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - CONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   - INCX
X  190                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( 1, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of CTBSV .
*
X      END
SHAR_EOF
chmod 0664 ctbsv.f ||
echo 'restore of ctbsv.f failed'
Wc_c="`wc -c < 'ctbsv.f'`"
test 13158 -eq "$Wc_c" ||
	echo 'ctbsv.f: original size 13158, current size' "$Wc_c"
fi
# ============= ctpsv.f ==============
if test -f 'ctpsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ctpsv.f (File already exists)'
else
echo 'x - extracting ctpsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ctpsv.f' &&
*
************************************************************************
*
X      SUBROUTINE CTPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX            AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CTPSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix, supplied in packed form.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX          array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CTPSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     - 1
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      - 1
X   10                CONTINUE
X                  END IF
X                  KK = KK - J
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, K = KK - 1, KK - J + 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     + 1
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      + 1
X   50                CONTINUE
X                  END IF
X                  KK = KK + ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, K = KK + 1, KK + N - J
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = 1, N
X                  TEMP = X( J )
X                  K    = KK
X                  IF( NOCONJ )THEN
X                     DO 90, I = 1, J - 1
X                        TEMP = TEMP - AP( K )*X( I )
X                        K    = K    + 1
X   90                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK + J - 1 )
X                  ELSE
X                     DO 100, I = 1, J - 1
X                        TEMP = TEMP - CONJG( AP( K ) )*X( I )
X                        K    = K    + 1
X  100                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( AP( KK + J - 1 ) )
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   + J
X  110          CONTINUE
X            ELSE
X               JX = KX
X               DO 140, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  IF( NOCONJ )THEN
X                     DO 120, K = KK, KK + J - 2
X                        TEMP = TEMP - AP( K )*X( IX )
X                        IX   = IX   + INCX
X  120                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK + J - 1 )
X                  ELSE
X                     DO 130, K = KK, KK + J - 2
X                        TEMP = TEMP - CONJG( AP( K ) )*X( IX )
X                        IX   = IX   + INCX
X  130                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( AP( KK + J - 1 ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + J
X  140          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = N, 1, -1
X                  TEMP = X( J )
X                  K    = KK
X                  IF( NOCONJ )THEN
X                     DO 150, I = N, J + 1, -1
X                        TEMP = TEMP - AP( K )*X( I )
X                        K    = K    - 1
X  150                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK - N + J )
X                  ELSE
X                     DO 160, I = N, J + 1, -1
X                        TEMP = TEMP - CONJG( AP( K ) )*X( I )
X                        K    = K    - 1
X  160                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( AP( KK - N + J ) )
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   - ( N - J + 1 )
X  170          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 200, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  IF( NOCONJ )THEN
X                     DO 180, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        TEMP = TEMP - AP( K )*X( IX )
X                        IX   = IX   - INCX
X  180                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK - N + J )
X                  ELSE
X                     DO 190, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        TEMP = TEMP - CONJG( AP( K ) )*X( IX )
X                        IX   = IX   - INCX
X  190                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( AP( KK - N + J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - ( N - J + 1 )
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of CTPSV .
*
X      END
SHAR_EOF
chmod 0664 ctpsv.f ||
echo 'restore of ctpsv.f failed'
Wc_c="`wc -c < 'ctpsv.f'`"
test 11403 -eq "$Wc_c" ||
	echo 'ctpsv.f: original size 11403, current size' "$Wc_c"
fi
# ============= ctrsv.f ==============
if test -f 'ctrsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ctrsv.f (File already exists)'
else
echo 'x - extracting ctrsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ctrsv.f' &&
*
************************************************************************
*
X      SUBROUTINE CTRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CTRSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CTRSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, I = J - 1, 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, I = J + 1, N
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = 1, N
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     DO 90, I = 1, J - 1
X                        TEMP = TEMP - A( I, J )*X( I )
X   90                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 100, I = 1, J - 1
X                        TEMP = TEMP - CONJG( A( I, J ) )*X( I )
X  100                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( J, J ) )
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               JX = KX
X               DO 140, J = 1, N
X                  IX   = KX
X                  TEMP = X( JX )
X                  IF( NOCONJ )THEN
X                     DO 120, I = 1, J - 1
X                        TEMP = TEMP - A( I, J )*X( IX )
X                        IX   = IX   + INCX
X  120                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 130, I = 1, J - 1
X                        TEMP = TEMP - CONJG( A( I, J ) )*X( IX )
X                        IX   = IX   + INCX
X  130                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( J, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     DO 150, I = N, J + 1, -1
X                        TEMP = TEMP - A( I, J )*X( I )
X  150                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 160, I = N, J + 1, -1
X                        TEMP = TEMP - CONJG( A( I, J ) )*X( I )
X  160                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( J, J ) )
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 200, J = N, 1, -1
X                  IX   = KX
X                  TEMP = X( JX )
X                  IF( NOCONJ )THEN
X                     DO 180, I = N, J + 1, -1
X                        TEMP = TEMP - A( I, J )*X( IX )
X                        IX   = IX   - INCX
X  180                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 190, I = N, J + 1, -1
X                        TEMP = TEMP - CONJG( A( I, J ) )*X( IX )
X                        IX   = IX   - INCX
X  190                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/CONJG( A( J, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of CTRSV .
*
X      END
SHAR_EOF
chmod 0664 ctrsv.f ||
echo 'restore of ctrsv.f failed'
Wc_c="`wc -c < 'ctrsv.f'`"
test 10619 -eq "$Wc_c" ||
	echo 'ctrsv.f: original size 10619, current size' "$Wc_c"
fi
# ============= dtbsv.f ==============
if test -f 'dtbsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dtbsv.f (File already exists)'
else
echo 'x - extracting dtbsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dtbsv.f' &&
*
************************************************************************
*
X      SUBROUTINE DTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTBSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
*  diagonals.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DTBSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed by sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     L = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( KPLUS1, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, MAX( 1, J - K ), -1
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 40, J = N, 1, -1
X                  KX = KX - INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( KPLUS1, J )
X                     TEMP = X( JX )
X                     DO 30, I = J - 1, MAX( 1, J - K ), -1
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     L = 1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( 1, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, MIN( N, J + K )
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  KX = KX + INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = 1  - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( 1, J )
X                     TEMP = X( JX )
X                     DO 70, I = J + 1, MIN( N, J + K )
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A')*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = 1, N
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  DO 90, I = MAX( 1, J - K ), J - 1
X                     TEMP = TEMP - A( L + I, J )*X( I )
X   90             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( KPLUS1, J )
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               JX = KX
X               DO 120, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  DO 110, I = MAX( 1, J - K ), J - 1
X                     TEMP = TEMP - A( L + I, J )*X( IX )
X                     IX   = IX   + INCX
X  110             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( KPLUS1, J )
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = 1      - J
X                  DO 130, I = MIN( N, J + K ), J + 1, -1
X                     TEMP = TEMP - A( L + I, J )*X( I )
X  130             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( 1, J )
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 160, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = 1       - J
X                  DO 150, I = MIN( N, J + K ), J + 1, -1
X                     TEMP = TEMP - A( L + I, J )*X( IX )
X                     IX   = IX   - INCX
X  150             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( 1, J )
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of DTBSV .
*
X      END
SHAR_EOF
chmod 0664 dtbsv.f ||
echo 'restore of dtbsv.f failed'
Wc_c="`wc -c < 'dtbsv.f'`"
test 11553 -eq "$Wc_c" ||
	echo 'dtbsv.f: original size 11553, current size' "$Wc_c"
fi
# ============= dtpsv.f ==============
if test -f 'dtpsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dtpsv.f (File already exists)'
else
echo 'x - extracting dtpsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dtpsv.f' &&
*
************************************************************************
*
X      SUBROUTINE DTPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTPSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix, supplied in packed form.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - DOUBLE PRECISION array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DTPSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     - 1
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      - 1
X   10                CONTINUE
X                  END IF
X                  KK = KK - J
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, K = KK - 1, KK - J + 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     + 1
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      + 1
X   50                CONTINUE
X                  END IF
X                  KK = KK + ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, K = KK + 1, KK + N - J
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = 1, N
X                  TEMP = X( J )
X                  K    = KK
X                  DO 90, I = 1, J - 1
X                     TEMP = TEMP - AP( K )*X( I )
X                     K    = K    + 1
X   90             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK + J - 1 )
X                  X( J ) = TEMP
X                  KK     = KK   + J
X  100          CONTINUE
X            ELSE
X               JX = KX
X               DO 120, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 110, K = KK, KK + J - 2
X                     TEMP = TEMP - AP( K )*X( IX )
X                     IX   = IX   + INCX
X  110             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK + J - 1 )
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + J
X  120          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = N, 1, -1
X                  TEMP = X( J )
X                  K = KK
X                  DO 130, I = N, J + 1, -1
X                     TEMP = TEMP - AP( K )*X( I )
X                     K    = K    - 1
X  130             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK - N + J )
X                  X( J ) = TEMP
X                  KK     = KK   - ( N - J + 1 )
X  140          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 160, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 150, K = KK, KK - ( N - ( J + 1 ) ), -1
X                     TEMP = TEMP - AP( K )*X( IX )
X                     IX   = IX   - INCX
X  150             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK - N + J )
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - (N - J + 1 )
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of DTPSV .
*
X      END
SHAR_EOF
chmod 0664 dtpsv.f ||
echo 'restore of dtpsv.f failed'
Wc_c="`wc -c < 'dtpsv.f'`"
test 9690 -eq "$Wc_c" ||
	echo 'dtpsv.f: original size 9690, current size' "$Wc_c"
fi
# ============= dtrsv.f ==============
if test -f 'dtrsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dtrsv.f (File already exists)'
else
echo 'x - extracting dtrsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dtrsv.f' &&
*
************************************************************************
*
X      SUBROUTINE DTRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTRSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DTRSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, I = J - 1, 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, I = J + 1, N
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = 1, N
X                  TEMP = X( J )
X                  DO 90, I = 1, J - 1
X                     TEMP = TEMP - A( I, J )*X( I )
X   90             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               JX = KX
X               DO 120, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 110, I = 1, J - 1
X                     TEMP = TEMP - A( I, J )*X( IX )
X                     IX   = IX   + INCX
X  110             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = N, 1, -1
X                  TEMP = X( J )
X                  DO 130, I = N, J + 1, -1
X                     TEMP = TEMP - A( I, J )*X( I )
X  130             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 160, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 150, I = N, J + 1, -1
X                     TEMP = TEMP - A( I, J )*X( IX )
X                     IX   = IX   - INCX
X  150             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of DTRSV .
*
X      END
SHAR_EOF
chmod 0664 dtrsv.f ||
echo 'restore of dtrsv.f failed'
Wc_c="`wc -c < 'dtrsv.f'`"
test 9096 -eq "$Wc_c" ||
	echo 'dtrsv.f: original size 9096, current size' "$Wc_c"
fi
# ============= stbsv.f ==============
if test -f 'stbsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping stbsv.f (File already exists)'
else
echo 'x - extracting stbsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'stbsv.f' &&
*
************************************************************************
*
X      SUBROUTINE STBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  STBSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
*  diagonals.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'STBSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed by sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     L = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( KPLUS1, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, MAX( 1, J - K ), -1
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 40, J = N, 1, -1
X                  KX = KX - INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( KPLUS1, J )
X                     TEMP = X( JX )
X                     DO 30, I = J - 1, MAX( 1, J - K ), -1
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     L = 1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( 1, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, MIN( N, J + K )
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  KX = KX + INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = 1  - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( 1, J )
X                     TEMP = X( JX )
X                     DO 70, I = J + 1, MIN( N, J + K )
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A')*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = 1, N
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  DO 90, I = MAX( 1, J - K ), J - 1
X                     TEMP = TEMP - A( L + I, J )*X( I )
X   90             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( KPLUS1, J )
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               JX = KX
X               DO 120, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  DO 110, I = MAX( 1, J - K ), J - 1
X                     TEMP = TEMP - A( L + I, J )*X( IX )
X                     IX   = IX   + INCX
X  110             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( KPLUS1, J )
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = 1      - J
X                  DO 130, I = MIN( N, J + K ), J + 1, -1
X                     TEMP = TEMP - A( L + I, J )*X( I )
X  130             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( 1, J )
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 160, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = 1       - J
X                  DO 150, I = MIN( N, J + K ), J + 1, -1
X                     TEMP = TEMP - A( L + I, J )*X( IX )
X                     IX   = IX   - INCX
X  150             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( 1, J )
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of STBSV .
*
X      END
SHAR_EOF
chmod 0664 stbsv.f ||
echo 'restore of stbsv.f failed'
Wc_c="`wc -c < 'stbsv.f'`"
test 11553 -eq "$Wc_c" ||
	echo 'stbsv.f: original size 11553, current size' "$Wc_c"
fi
# ============= stpsv.f ==============
if test -f 'stpsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping stpsv.f (File already exists)'
else
echo 'x - extracting stpsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'stpsv.f' &&
*
************************************************************************
*
X      SUBROUTINE STPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      REAL               AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  STPSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix, supplied in packed form.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - REAL             array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'STPSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     - 1
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      - 1
X   10                CONTINUE
X                  END IF
X                  KK = KK - J
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, K = KK - 1, KK - J + 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     + 1
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      + 1
X   50                CONTINUE
X                  END IF
X                  KK = KK + ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, K = KK + 1, KK + N - J
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = 1, N
X                  TEMP = X( J )
X                  K    = KK
X                  DO 90, I = 1, J - 1
X                     TEMP = TEMP - AP( K )*X( I )
X                     K    = K    + 1
X   90             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK + J - 1 )
X                  X( J ) = TEMP
X                  KK     = KK   + J
X  100          CONTINUE
X            ELSE
X               JX = KX
X               DO 120, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 110, K = KK, KK + J - 2
X                     TEMP = TEMP - AP( K )*X( IX )
X                     IX   = IX   + INCX
X  110             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK + J - 1 )
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + J
X  120          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = N, 1, -1
X                  TEMP = X( J )
X                  K = KK
X                  DO 130, I = N, J + 1, -1
X                     TEMP = TEMP - AP( K )*X( I )
X                     K    = K    - 1
X  130             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK - N + J )
X                  X( J ) = TEMP
X                  KK     = KK   - ( N - J + 1 )
X  140          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 160, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 150, K = KK, KK - ( N - ( J + 1 ) ), -1
X                     TEMP = TEMP - AP( K )*X( IX )
X                     IX   = IX   - INCX
X  150             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/AP( KK - N + J )
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - (N - J + 1 )
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of STPSV .
*
X      END
SHAR_EOF
chmod 0664 stpsv.f ||
echo 'restore of stpsv.f failed'
Wc_c="`wc -c < 'stpsv.f'`"
test 9690 -eq "$Wc_c" ||
	echo 'stpsv.f: original size 9690, current size' "$Wc_c"
fi
# ============= strsv.f ==============
if test -f 'strsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping strsv.f (File already exists)'
else
echo 'x - extracting strsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'strsv.f' &&
*
************************************************************************
*
X      SUBROUTINE STRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  STRSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'STRSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, I = J - 1, 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, I = J + 1, N
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 100, J = 1, N
X                  TEMP = X( J )
X                  DO 90, I = 1, J - 1
X                     TEMP = TEMP - A( I, J )*X( I )
X   90             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( J ) = TEMP
X  100          CONTINUE
X            ELSE
X               JX = KX
X               DO 120, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 110, I = 1, J - 1
X                     TEMP = TEMP - A( I, J )*X( IX )
X                     IX   = IX   + INCX
X  110             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  120          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 140, J = N, 1, -1
X                  TEMP = X( J )
X                  DO 130, I = N, J + 1, -1
X                     TEMP = TEMP - A( I, J )*X( I )
X  130             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( J ) = TEMP
X  140          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 160, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  DO 150, I = N, J + 1, -1
X                     TEMP = TEMP - A( I, J )*X( IX )
X                     IX   = IX   - INCX
X  150             CONTINUE
X                  IF( NOUNIT )
X     $               TEMP = TEMP/A( J, J )
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  160          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of STRSV .
*
X      END
SHAR_EOF
chmod 0664 strsv.f ||
echo 'restore of strsv.f failed'
Wc_c="`wc -c < 'strsv.f'`"
test 9096 -eq "$Wc_c" ||
	echo 'strsv.f: original size 9096, current size' "$Wc_c"
fi
# ============= ztbsv.f ==============
if test -f 'ztbsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ztbsv.f (File already exists)'
else
echo 'x - extracting ztbsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ztbsv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, K, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZTBSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
*  diagonals.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( K.LT.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.( K + 1 ) )THEN
X         INFO = 7
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZTBSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed by sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     L = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( KPLUS1, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, MAX( 1, J - K ), -1
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 40, J = N, 1, -1
X                  KX = KX - INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = KPLUS1 - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( KPLUS1, J )
X                     TEMP = X( JX )
X                     DO 30, I = J - 1, MAX( 1, J - K ), -1
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      - INCX
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     L = 1 - J
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( 1, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, MIN( N, J + K )
X                        X( I ) = X( I ) - TEMP*A( L + I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  KX = KX + INCX
X                  IF( X( JX ).NE.ZERO )THEN
X                     IX = KX
X                     L  = 1  - J
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( 1, J )
X                     TEMP = X( JX )
X                     DO 70, I = J + 1, MIN( N, J + K )
X                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
X                        IX      = IX      + INCX
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x  or  x := inv( conjg( A') )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KPLUS1 = K + 1
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = 1, N
X                  TEMP = X( J )
X                  L    = KPLUS1 - J
X                  IF( NOCONJ )THEN
X                     DO 90, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - A( L + I, J )*X( I )
X   90                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( KPLUS1, J )
X                  ELSE
X                     DO 100, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - DCONJG( A( L + I, J ) )*X( I )
X  100                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( KPLUS1, J ) )
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               JX = KX
X               DO 140, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = KPLUS1  - J
X                  IF( NOCONJ )THEN
X                     DO 120, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - A( L + I, J )*X( IX )
X                        IX   = IX   + INCX
X  120                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( KPLUS1, J )
X                  ELSE
X                     DO 130, I = MAX( 1, J - K ), J - 1
X                        TEMP = TEMP - DCONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   + INCX
X  130                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( KPLUS1, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  IF( J.GT.K )
X     $               KX = KX + INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = N, 1, -1
X                  TEMP = X( J )
X                  L    = 1      - J
X                  IF( NOCONJ )THEN
X                     DO 150, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - A( L + I, J )*X( I )
X  150                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( 1, J )
X                  ELSE
X                     DO 160, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - DCONJG( A( L + I, J ) )*X( I )
X  160                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( 1, J ) )
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 200, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  L    = 1       - J
X                  IF( NOCONJ )THEN
X                     DO 180, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - A( L + I, J )*X( IX )
X                        IX   = IX   - INCX
X  180                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( 1, J )
X                  ELSE
X                     DO 190, I = MIN( N, J + K ), J + 1, -1
X                        TEMP = TEMP - DCONJG( A( L + I, J ) )*X( IX )
X                        IX   = IX   - INCX
X  190                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( 1, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  IF( ( N - J ).GE.K )
X     $               KX = KX - INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZTBSV .
*
X      END
SHAR_EOF
chmod 0664 ztbsv.f ||
echo 'restore of ztbsv.f failed'
Wc_c="`wc -c < 'ztbsv.f'`"
test 13167 -eq "$Wc_c" ||
	echo 'ztbsv.f: original size 13167, current size' "$Wc_c"
fi
# ============= ztpsv.f ==============
if test -f 'ztpsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ztpsv.f (File already exists)'
else
echo 'x - extracting ztpsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ztpsv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZTPSV ( UPLO, TRANS, DIAG, N, AP, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX*16         AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZTPSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix, supplied in packed form.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX*16       array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
*           respectively, and so on.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular matrix packed sequentially,
*           column by column, so that AP( 1 ) contains a( 1, 1 ),
*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
*           respectively, and so on.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZTPSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of AP are
*     accessed sequentially with one pass through AP.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     - 1
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      - 1
X   10                CONTINUE
X                  END IF
X                  KK = KK - J
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, K = KK - 1, KK - J + 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X                  KK = KK - J
X   40          CONTINUE
X            END IF
X         ELSE
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/AP( KK )
X                     TEMP = X( J )
X                     K    = KK     + 1
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*AP( K )
X                        K      = K      + 1
X   50                CONTINUE
X                  END IF
X                  KK = KK + ( N - J + 1 )
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/AP( KK )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, K = KK + 1, KK + N - J
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*AP( K )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X                  KK = KK + ( N - J + 1 )
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            KK = 1
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = 1, N
X                  TEMP = X( J )
X                  K    = KK
X                  IF( NOCONJ )THEN
X                     DO 90, I = 1, J - 1
X                        TEMP = TEMP - AP( K )*X( I )
X                        K    = K    + 1
X   90                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK + J - 1 )
X                  ELSE
X                     DO 100, I = 1, J - 1
X                        TEMP = TEMP - DCONJG( AP( K ) )*X( I )
X                        K    = K    + 1
X  100                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( AP( KK + J - 1 ) )
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   + J
X  110          CONTINUE
X            ELSE
X               JX = KX
X               DO 140, J = 1, N
X                  TEMP = X( JX )
X                  IX   = KX
X                  IF( NOCONJ )THEN
X                     DO 120, K = KK, KK + J - 2
X                        TEMP = TEMP - AP( K )*X( IX )
X                        IX   = IX   + INCX
X  120                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK + J - 1 )
X                  ELSE
X                     DO 130, K = KK, KK + J - 2
X                        TEMP = TEMP - DCONJG( AP( K ) )*X( IX )
X                        IX   = IX   + INCX
X  130                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( AP( KK + J - 1 ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X                  KK      = KK   + J
X  140          CONTINUE
X            END IF
X         ELSE
X            KK = ( N*( N + 1 ) )/2
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = N, 1, -1
X                  TEMP = X( J )
X                  K    = KK
X                  IF( NOCONJ )THEN
X                     DO 150, I = N, J + 1, -1
X                        TEMP = TEMP - AP( K )*X( I )
X                        K    = K    - 1
X  150                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK - N + J )
X                  ELSE
X                     DO 160, I = N, J + 1, -1
X                        TEMP = TEMP - DCONJG( AP( K ) )*X( I )
X                        K    = K    - 1
X  160                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( AP( KK - N + J ) )
X                  END IF
X                  X( J ) = TEMP
X                  KK     = KK   - ( N - J + 1 )
X  170          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 200, J = N, 1, -1
X                  TEMP = X( JX )
X                  IX   = KX
X                  IF( NOCONJ )THEN
X                     DO 180, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        TEMP = TEMP - AP( K )*X( IX )
X                        IX   = IX   - INCX
X  180                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/AP( KK - N + J )
X                  ELSE
X                     DO 190, K = KK, KK - ( N - ( J + 1 ) ), -1
X                        TEMP = TEMP - DCONJG( AP( K ) )*X( IX )
X                        IX   = IX   - INCX
X  190                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( AP( KK - N + J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X                  KK      = KK   - ( N - J + 1 )
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZTPSV .
*
X      END
SHAR_EOF
chmod 0664 ztpsv.f ||
echo 'restore of ztpsv.f failed'
Wc_c="`wc -c < 'ztpsv.f'`"
test 11412 -eq "$Wc_c" ||
	echo 'ztpsv.f: original size 11412, current size' "$Wc_c"
fi
# ============= ztrsv.f ==============
if test -f 'ztrsv.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ztrsv.f (File already exists)'
else
echo 'x - extracting ztrsv.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ztrsv.f' &&
*
************************************************************************
*
X      SUBROUTINE ZTRSV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZTRSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular matrix.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
X      LOGICAL            NOCONJ, NOUNIT
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
X     $         .NOT.LSAME( UPLO , 'L' )      )THEN
X         INFO = 1
X      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
X     $         .NOT.LSAME( TRANS, 'T' ).AND.
X     $         .NOT.LSAME( TRANS, 'C' )      )THEN
X         INFO = 2
X      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
X     $         .NOT.LSAME( DIAG , 'N' )      )THEN
X         INFO = 3
X      ELSE IF( N.LT.0 )THEN
X         INFO = 4
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 6
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 8
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZTRSV ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( N.EQ.0 )
X     $   RETURN
*
X      NOCONJ = LSAME( TRANS, 'T' )
X      NOUNIT = LSAME( DIAG , 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 20, J = N, 1, -1
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 10, I = J - 1, 1, -1
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   10                CONTINUE
X                  END IF
X   20          CONTINUE
X            ELSE
X               JX = KX + ( N - 1 )*INCX
X               DO 40, J = N, 1, -1
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 30, I = J - 1, 1, -1
X                        IX      = IX      - INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   30                CONTINUE
X                  END IF
X                  JX = JX - INCX
X   40          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 60, J = 1, N
X                  IF( X( J ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( J ) = X( J )/A( J, J )
X                     TEMP = X( J )
X                     DO 50, I = J + 1, N
X                        X( I ) = X( I ) - TEMP*A( I, J )
X   50                CONTINUE
X                  END IF
X   60          CONTINUE
X            ELSE
X               JX = KX
X               DO 80, J = 1, N
X                  IF( X( JX ).NE.ZERO )THEN
X                     IF( NOUNIT )
X     $                  X( JX ) = X( JX )/A( J, J )
X                     TEMP = X( JX )
X                     IX   = JX
X                     DO 70, I = J + 1, N
X                        IX      = IX      + INCX
X                        X( IX ) = X( IX ) - TEMP*A( I, J )
X   70                CONTINUE
X                  END IF
X                  JX = JX + INCX
X   80          CONTINUE
X            END IF
X         END IF
X      ELSE
*
*        Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x.
*
X         IF( LSAME( UPLO, 'U' ) )THEN
X            IF( INCX.EQ.1 )THEN
X               DO 110, J = 1, N
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     DO 90, I = 1, J - 1
X                        TEMP = TEMP - A( I, J )*X( I )
X   90                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 100, I = 1, J - 1
X                        TEMP = TEMP - DCONJG( A( I, J ) )*X( I )
X  100                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( J, J ) )
X                  END IF
X                  X( J ) = TEMP
X  110          CONTINUE
X            ELSE
X               JX = KX
X               DO 140, J = 1, N
X                  IX   = KX
X                  TEMP = X( JX )
X                  IF( NOCONJ )THEN
X                     DO 120, I = 1, J - 1
X                        TEMP = TEMP - A( I, J )*X( IX )
X                        IX   = IX   + INCX
X  120                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 130, I = 1, J - 1
X                        TEMP = TEMP - DCONJG( A( I, J ) )*X( IX )
X                        IX   = IX   + INCX
X  130                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( J, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   + INCX
X  140          CONTINUE
X            END IF
X         ELSE
X            IF( INCX.EQ.1 )THEN
X               DO 170, J = N, 1, -1
X                  TEMP = X( J )
X                  IF( NOCONJ )THEN
X                     DO 150, I = N, J + 1, -1
X                        TEMP = TEMP - A( I, J )*X( I )
X  150                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 160, I = N, J + 1, -1
X                        TEMP = TEMP - DCONJG( A( I, J ) )*X( I )
X  160                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( J, J ) )
X                  END IF
X                  X( J ) = TEMP
X  170          CONTINUE
X            ELSE
X               KX = KX + ( N - 1 )*INCX
X               JX = KX
X               DO 200, J = N, 1, -1
X                  IX   = KX
X                  TEMP = X( JX )
X                  IF( NOCONJ )THEN
X                     DO 180, I = N, J + 1, -1
X                        TEMP = TEMP - A( I, J )*X( IX )
X                        IX   = IX   - INCX
X  180                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/A( J, J )
X                  ELSE
X                     DO 190, I = N, J + 1, -1
X                        TEMP = TEMP - DCONJG( A( I, J ) )*X( IX )
X                        IX   = IX   - INCX
X  190                CONTINUE
X                     IF( NOUNIT )
X     $                  TEMP = TEMP/DCONJG( A( J, J ) )
X                  END IF
X                  X( JX ) = TEMP
X                  JX      = JX   - INCX
X  200          CONTINUE
X            END IF
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZTRSV .
*
X      END
SHAR_EOF
chmod 0664 ztrsv.f ||
echo 'restore of ztrsv.f failed'
Wc_c="`wc -c < 'ztrsv.f'`"
test 10628 -eq "$Wc_c" ||
	echo 'ztrsv.f: original size 10628, current size' "$Wc_c"
fi
# ============= dger.f ==============
if test -f 'dger.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dger.f (File already exists)'
else
echo 'x - extracting dger.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dger.f' &&
*
************************************************************************
*
X      SUBROUTINE DGER  ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DGER   performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( M.LT.0 )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DGER  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( INCY.GT.0 )THEN
X         JY = 1
X      ELSE
X         JY = 1 - ( N - 1 )*INCY
X      END IF
X      IF( INCX.EQ.1 )THEN
X         DO 20, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               DO 10, I = 1, M
X                  A( I, J ) = A( I, J ) + X( I )*TEMP
X   10          CONTINUE
X            END IF
X            JY = JY + INCY
X   20    CONTINUE
X      ELSE
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( M - 1 )*INCX
X         END IF
X         DO 40, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               IX   = KX
X               DO 30, I = 1, M
X                  A( I, J ) = A( I, J ) + X( IX )*TEMP
X                  IX        = IX        + INCX
X   30          CONTINUE
X            END IF
X            JY = JY + INCY
X   40    CONTINUE
X      END IF
*
X      RETURN
*
*     End of DGER  .
*
X      END
SHAR_EOF
chmod 0664 dger.f ||
echo 'restore of dger.f failed'
Wc_c="`wc -c < 'dger.f'`"
test 4443 -eq "$Wc_c" ||
	echo 'dger.f: original size 4443, current size' "$Wc_c"
fi
# ============= sger.f ==============
if test -f 'sger.f' -a X"$1" != X"-c"; then
	echo 'x - skipping sger.f (File already exists)'
else
echo 'x - extracting sger.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'sger.f' &&
*
************************************************************************
*
X      SUBROUTINE SGER  ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SGER   performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( M.LT.0 )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SGER  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( INCY.GT.0 )THEN
X         JY = 1
X      ELSE
X         JY = 1 - ( N - 1 )*INCY
X      END IF
X      IF( INCX.EQ.1 )THEN
X         DO 20, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               DO 10, I = 1, M
X                  A( I, J ) = A( I, J ) + X( I )*TEMP
X   10          CONTINUE
X            END IF
X            JY = JY + INCY
X   20    CONTINUE
X      ELSE
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( M - 1 )*INCX
X         END IF
X         DO 40, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               IX   = KX
X               DO 30, I = 1, M
X                  A( I, J ) = A( I, J ) + X( IX )*TEMP
X                  IX        = IX        + INCX
X   30          CONTINUE
X            END IF
X            JY = JY + INCY
X   40    CONTINUE
X      END IF
*
X      RETURN
*
*     End of SGER  .
*
X      END
SHAR_EOF
chmod 0664 sger.f ||
echo 'restore of sger.f failed'
Wc_c="`wc -c < 'sger.f'`"
test 4443 -eq "$Wc_c" ||
	echo 'sger.f: original size 4443, current size' "$Wc_c"
fi
# ============= cgeru.f ==============
if test -f 'cgeru.f' -a X"$1" != X"-c"; then
	echo 'x - skipping cgeru.f (File already exists)'
else
echo 'x - extracting cgeru.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cgeru.f' &&
*
************************************************************************
*
X      SUBROUTINE CGERU ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA
X      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CGERU  performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( M.LT.0 )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CGERU ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( INCY.GT.0 )THEN
X         JY = 1
X      ELSE
X         JY = 1 - ( N - 1 )*INCY
X      END IF
X      IF( INCX.EQ.1 )THEN
X         DO 20, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               DO 10, I = 1, M
X                  A( I, J ) = A( I, J ) + X( I )*TEMP
X   10          CONTINUE
X            END IF
X            JY = JY + INCY
X   20    CONTINUE
X      ELSE
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( M - 1 )*INCX
X         END IF
X         DO 40, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               IX   = KX
X               DO 30, I = 1, M
X                  A( I, J ) = A( I, J ) + X( IX )*TEMP
X                  IX        = IX        + INCX
X   30          CONTINUE
X            END IF
X            JY = JY + INCY
X   40    CONTINUE
X      END IF
*
X      RETURN
*
*     End of CGERU .
*
X      END
SHAR_EOF
chmod 0664 cgeru.f ||
echo 'restore of cgeru.f failed'
Wc_c="`wc -c < 'cgeru.f'`"
test 4455 -eq "$Wc_c" ||
	echo 'cgeru.f: original size 4455, current size' "$Wc_c"
fi
# ============= zgeru.f ==============
if test -f 'zgeru.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zgeru.f (File already exists)'
else
echo 'x - extracting zgeru.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zgeru.f' &&
*
************************************************************************
*
X      SUBROUTINE ZGERU ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA
X      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZGERU  performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( M.LT.0 )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZGERU ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( INCY.GT.0 )THEN
X         JY = 1
X      ELSE
X         JY = 1 - ( N - 1 )*INCY
X      END IF
X      IF( INCX.EQ.1 )THEN
X         DO 20, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               DO 10, I = 1, M
X                  A( I, J ) = A( I, J ) + X( I )*TEMP
X   10          CONTINUE
X            END IF
X            JY = JY + INCY
X   20    CONTINUE
X      ELSE
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( M - 1 )*INCX
X         END IF
X         DO 40, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*Y( JY )
X               IX   = KX
X               DO 30, I = 1, M
X                  A( I, J ) = A( I, J ) + X( IX )*TEMP
X                  IX        = IX        + INCX
X   30          CONTINUE
X            END IF
X            JY = JY + INCY
X   40    CONTINUE
X      END IF
*
X      RETURN
*
*     End of ZGERU .
*
X      END
SHAR_EOF
chmod 0664 zgeru.f ||
echo 'restore of zgeru.f failed'
Wc_c="`wc -c < 'zgeru.f'`"
test 4455 -eq "$Wc_c" ||
	echo 'zgeru.f: original size 4455, current size' "$Wc_c"
fi
# ============= cgerc.f ==============
if test -f 'cgerc.f' -a X"$1" != X"-c"; then
	echo 'x - skipping cgerc.f (File already exists)'
else
echo 'x - extracting cgerc.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cgerc.f' &&
*
************************************************************************
*
X      SUBROUTINE CGERC ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA
X      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CGERC  performs the rank 1 operation
*
*     A := alpha*x*conjg( y' ) + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( M.LT.0 )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CGERC ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( INCY.GT.0 )THEN
X         JY = 1
X      ELSE
X         JY = 1 - ( N - 1 )*INCY
X      END IF
X      IF( INCX.EQ.1 )THEN
X         DO 20, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*CONJG( Y( JY ) )
X               DO 10, I = 1, M
X                  A( I, J ) = A( I, J ) + X( I )*TEMP
X   10          CONTINUE
X            END IF
X            JY = JY + INCY
X   20    CONTINUE
X      ELSE
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( M - 1 )*INCX
X         END IF
X         DO 40, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*CONJG( Y( JY ) )
X               IX   = KX
X               DO 30, I = 1, M
X                  A( I, J ) = A( I, J ) + X( IX )*TEMP
X                  IX        = IX        + INCX
X   30          CONTINUE
X            END IF
X            JY = JY + INCY
X   40    CONTINUE
X      END IF
*
X      RETURN
*
*     End of CGERC .
*
X      END
SHAR_EOF
chmod 0664 cgerc.f ||
echo 'restore of cgerc.f failed'
Wc_c="`wc -c < 'cgerc.f'`"
test 4489 -eq "$Wc_c" ||
	echo 'cgerc.f: original size 4489, current size' "$Wc_c"
fi
# ============= zgerc.f ==============
if test -f 'zgerc.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zgerc.f (File already exists)'
else
echo 'x - extracting zgerc.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zgerc.f' &&
*
************************************************************************
*
X      SUBROUTINE ZGERC ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA
X      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZGERC  performs the rank 1 operation
*
*     A := alpha*x*conjg( y' ) + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( M.LT.0 )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZGERC ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
X      IF( INCY.GT.0 )THEN
X         JY = 1
X      ELSE
X         JY = 1 - ( N - 1 )*INCY
X      END IF
X      IF( INCX.EQ.1 )THEN
X         DO 20, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*DCONJG( Y( JY ) )
X               DO 10, I = 1, M
X                  A( I, J ) = A( I, J ) + X( I )*TEMP
X   10          CONTINUE
X            END IF
X            JY = JY + INCY
X   20    CONTINUE
X      ELSE
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( M - 1 )*INCX
X         END IF
X         DO 40, J = 1, N
X            IF( Y( JY ).NE.ZERO )THEN
X               TEMP = ALPHA*DCONJG( Y( JY ) )
X               IX   = KX
X               DO 30, I = 1, M
X                  A( I, J ) = A( I, J ) + X( IX )*TEMP
X                  IX        = IX        + INCX
X   30          CONTINUE
X            END IF
X            JY = JY + INCY
X   40    CONTINUE
X      END IF
*
X      RETURN
*
*     End of ZGERC .
*
X      END
SHAR_EOF
chmod 0664 zgerc.f ||
echo 'restore of zgerc.f failed'
Wc_c="`wc -c < 'zgerc.f'`"
test 4492 -eq "$Wc_c" ||
	echo 'zgerc.f: original size 4492, current size' "$Wc_c"
fi
# ============= cher.f ==============
if test -f 'cher.f' -a X"$1" != X"-c"; then
	echo 'x - skipping cher.f (File already exists)'
else
echo 'x - extracting cher.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cher.f' &&
*
************************************************************************
*
X      SUBROUTINE CHER  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CHER   performs the hermitian rank 1 operation
*
*     A := alpha*x*conjg( x' ) + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n hermitian matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the hermitian matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the hermitian matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHER  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.REAL( ZERO ) ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in upper triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*CONJG( X( J ) )
X                  DO 10, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   10             CONTINUE
X                  A( J, J ) = REAL( A( J, J ) ) + REAL( X( J )*TEMP )
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*CONJG( X( JX ) )
X                  IX   = KX
X                  DO 30, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X                     IX        = IX        + INCX
X   30             CONTINUE
X                  A( J, J ) = REAL( A( J, J ) ) + REAL( X( JX )*TEMP )
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X               JX = JX + INCX
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in lower triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP      = ALPHA*CONJG( X( J ) )
X                  A( J, J ) = REAL( A( J, J ) ) + REAL( TEMP*X( J ) )
X                  DO 50, I = J + 1, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   50             CONTINUE
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP      = ALPHA*CONJG( X( JX ) )
X                  A( J, J ) = REAL( A( J, J ) ) + REAL( TEMP*X( JX ) )
X                  IX        = JX
X                  DO 70, I = J + 1, N
X                     IX        = IX        + INCX
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X   70             CONTINUE
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHER  .
*
X      END
SHAR_EOF
chmod 0664 cher.f ||
echo 'restore of cher.f failed'
Wc_c="`wc -c < 'cher.f'`"
test 6875 -eq "$Wc_c" ||
	echo 'cher.f: original size 6875, current size' "$Wc_c"
fi
# ============= zher.f ==============
if test -f 'zher.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zher.f (File already exists)'
else
echo 'x - extracting zher.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zher.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHER  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHER   performs the hermitian rank 1 operation
*
*     A := alpha*x*conjg( x' ) + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n hermitian matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the hermitian matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the hermitian matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHER  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.DBLE( ZERO ) ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in upper triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*DCONJG( X( J ) )
X                  DO 10, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   10             CONTINUE
X                  A( J, J ) = DBLE( A( J, J ) ) + DBLE( X( J )*TEMP )
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*DCONJG( X( JX ) )
X                  IX   = KX
X                  DO 30, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X                     IX        = IX        + INCX
X   30             CONTINUE
X                  A( J, J ) = DBLE( A( J, J ) ) + DBLE( X( JX )*TEMP )
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X               JX = JX + INCX
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in lower triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP      = ALPHA*DCONJG( X( J ) )
X                  A( J, J ) = DBLE( A( J, J ) ) + DBLE( TEMP*X( J ) )
X                  DO 50, I = J + 1, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   50             CONTINUE
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP      = ALPHA*DCONJG( X( JX ) )
X                  A( J, J ) = DBLE( A( J, J ) ) + DBLE( TEMP*X( JX ) )
X                  IX        = JX
X                  DO 70, I = J + 1, N
X                     IX        = IX        + INCX
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X   70             CONTINUE
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHER  .
*
X      END
SHAR_EOF
chmod 0664 zher.f ||
echo 'restore of zher.f failed'
Wc_c="`wc -c < 'zher.f'`"
test 6880 -eq "$Wc_c" ||
	echo 'zher.f: original size 6880, current size' "$Wc_c"
fi
# ============= chpr.f ==============
if test -f 'chpr.f' -a X"$1" != X"-c"; then
	echo 'x - skipping chpr.f (File already exists)'
else
echo 'x - extracting chpr.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'chpr.f' &&
*
************************************************************************
*
X      SUBROUTINE CHPR  ( UPLO, N, ALPHA, X, INCX, AP )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  CHPR    performs the hermitian rank 1 operation
*
*     A := alpha*x*conjg( x' ) + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n hermitian matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX          array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHPR  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.REAL( ZERO ) ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*CONJG( X( J ) )
X                  K    = KK
X                  DO 10, I = 1, J - 1
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   10             CONTINUE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) )
X     $                               + REAL( X( J )*TEMP )
X               ELSE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) )
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*CONJG( X( JX ) )
X                  IX   = KX
X                  DO 30, K = KK, KK + J - 2
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X                     IX      = IX      + INCX
X   30             CONTINUE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) )
X     $                               + REAL( X( JX )*TEMP )
X               ELSE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) )
X               END IF
X               JX = JX + INCX
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP     = ALPHA*CONJG( X( J ) )
X                  AP( KK ) = REAL( AP( KK ) ) + REAL( TEMP*X( J ) )
X                  K        = KK               + 1
X                  DO 50, I = J + 1, N
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   50             CONTINUE
X               ELSE
X                  AP( KK ) = REAL( AP( KK ) )
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP    = ALPHA*CONJG( X( JX ) )
X                  AP( KK ) = REAL( AP( KK ) ) + REAL( TEMP*X( JX ) )
X                  IX      = JX
X                  DO 70, K = KK + 1, KK + N - J
X                     IX      = IX      + INCX
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X   70             CONTINUE
X               ELSE
X                  AP( KK ) = REAL( AP( KK ) )
X               END IF
X               JX = JX + INCX
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHPR  .
*
X      END
SHAR_EOF
chmod 0664 chpr.f ||
echo 'restore of chpr.f failed'
Wc_c="`wc -c < 'chpr.f'`"
test 7106 -eq "$Wc_c" ||
	echo 'chpr.f: original size 7106, current size' "$Wc_c"
fi
# ============= zhpr.f ==============
if test -f 'zhpr.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zhpr.f (File already exists)'
else
echo 'x - extracting zhpr.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zhpr.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHPR  ( UPLO, N, ALPHA, X, INCX, AP )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHPR    performs the hermitian rank 1 operation
*
*     A := alpha*x*conjg( x' ) + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n hermitian matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX*16       array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHPR  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.DBLE( ZERO ) ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*DCONJG( X( J ) )
X                  K    = KK
X                  DO 10, I = 1, J - 1
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   10             CONTINUE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) )
X     $                               + DBLE( X( J )*TEMP )
X               ELSE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) )
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*DCONJG( X( JX ) )
X                  IX   = KX
X                  DO 30, K = KK, KK + J - 2
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X                     IX      = IX      + INCX
X   30             CONTINUE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) )
X     $                               + DBLE( X( JX )*TEMP )
X               ELSE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) )
X               END IF
X               JX = JX + INCX
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP     = ALPHA*DCONJG( X( J ) )
X                  AP( KK ) = DBLE( AP( KK ) ) + DBLE( TEMP*X( J ) )
X                  K        = KK               + 1
X                  DO 50, I = J + 1, N
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   50             CONTINUE
X               ELSE
X                  AP( KK ) = DBLE( AP( KK ) )
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP    = ALPHA*DCONJG( X( JX ) )
X                  AP( KK ) = DBLE( AP( KK ) ) + DBLE( TEMP*X( JX ) )
X                  IX      = JX
X                  DO 70, K = KK + 1, KK + N - J
X                     IX      = IX      + INCX
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X   70             CONTINUE
X               ELSE
X                  AP( KK ) = DBLE( AP( KK ) )
X               END IF
X               JX = JX + INCX
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHPR  .
*
X      END
SHAR_EOF
chmod 0664 zhpr.f ||
echo 'restore of zhpr.f failed'
Wc_c="`wc -c < 'zhpr.f'`"
test 7111 -eq "$Wc_c" ||
	echo 'zhpr.f: original size 7111, current size' "$Wc_c"
fi
# ============= cher2.f ==============
if test -f 'cher2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping cher2.f (File already exists)'
else
echo 'x - extracting cher2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cher2.f' &&
*
************************************************************************
*
X      SUBROUTINE CHER2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CHER2  performs the hermitian rank 2 operation
*
*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an n
*  by n hermitian matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the hermitian matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the hermitian matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, MAX, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHER2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*CONJG( Y( J ) )
X                  TEMP2 = CONJG( ALPHA*X( J ) )
X                  DO 10, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   10             CONTINUE
X                  A( J, J ) = REAL( A( J, J ) ) +
X     $                        REAL( X( J )*TEMP1 + Y( J )*TEMP2 )
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*CONJG( Y( JY ) )
X                  TEMP2 = CONJG( ALPHA*X( JX ) )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X   30             CONTINUE
X                  A( J, J ) = REAL( A( J, J ) ) +
X     $                        REAL( X( JX )*TEMP1 + Y( JY )*TEMP2 )
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1     = ALPHA*CONJG( Y( J ) )
X                  TEMP2     = CONJG( ALPHA*X( J ) )
X                  A( J, J ) = REAL( A( J, J ) ) +
X     $                        REAL( X( J )*TEMP1 + Y( J )*TEMP2 )
X                  DO 50, I = J + 1, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   50             CONTINUE
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1     = ALPHA*CONJG( Y( JY ) )
X                  TEMP2     = CONJG( ALPHA*X( JX ) )
X                  A( J, J ) = REAL( A( J, J ) ) +
X     $                        REAL( X( JX )*TEMP1 + Y( JY )*TEMP2 )
X                  IX        = JX
X                  IY        = JY
X                  DO 70, I = J + 1, N
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X   70             CONTINUE
X               ELSE
X                  A( J, J ) = REAL( A( J, J ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHER2 .
*
X      END
SHAR_EOF
chmod 0664 cher2.f ||
echo 'restore of cher2.f failed'
Wc_c="`wc -c < 'cher2.f'`"
test 8494 -eq "$Wc_c" ||
	echo 'cher2.f: original size 8494, current size' "$Wc_c"
fi
# ============= zher2.f ==============
if test -f 'zher2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zher2.f (File already exists)'
else
echo 'x - extracting zher2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zher2.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHER2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHER2  performs the hermitian rank 2 operation
*
*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an n
*  by n hermitian matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the hermitian matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the hermitian matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, MAX, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHER2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*DCONJG( Y( J ) )
X                  TEMP2 = DCONJG( ALPHA*X( J ) )
X                  DO 10, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   10             CONTINUE
X                  A( J, J ) = DBLE( A( J, J ) ) +
X     $                        DBLE( X( J )*TEMP1 + Y( J )*TEMP2 )
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*DCONJG( Y( JY ) )
X                  TEMP2 = DCONJG( ALPHA*X( JX ) )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, I = 1, J - 1
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X   30             CONTINUE
X                  A( J, J ) = DBLE( A( J, J ) ) +
X     $                        DBLE( X( JX )*TEMP1 + Y( JY )*TEMP2 )
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1     = ALPHA*DCONJG( Y( J ) )
X                  TEMP2     = DCONJG( ALPHA*X( J ) )
X                  A( J, J ) = DBLE( A( J, J ) ) +
X     $                        DBLE( X( J )*TEMP1 + Y( J )*TEMP2 )
X                  DO 50, I = J + 1, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   50             CONTINUE
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1     = ALPHA*DCONJG( Y( JY ) )
X                  TEMP2     = DCONJG( ALPHA*X( JX ) )
X                  A( J, J ) = DBLE( A( J, J ) ) +
X     $                        DBLE( X( JX )*TEMP1 + Y( JY )*TEMP2 )
X                  IX        = JX
X                  IY        = JY
X                  DO 70, I = J + 1, N
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X   70             CONTINUE
X               ELSE
X                  A( J, J ) = DBLE( A( J, J ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHER2 .
*
X      END
SHAR_EOF
chmod 0664 zher2.f ||
echo 'restore of zher2.f failed'
Wc_c="`wc -c < 'zher2.f'`"
test 8503 -eq "$Wc_c" ||
	echo 'zher2.f: original size 8503, current size' "$Wc_c"
fi
# ============= chpr2.f ==============
if test -f 'chpr2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping chpr2.f (File already exists)'
else
echo 'x - extracting chpr2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'chpr2.f' &&
*
************************************************************************
*
X      SUBROUTINE CHPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*     .. Scalar Arguments ..
X      COMPLEX            ALPHA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX            AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  CHPR2  performs the hermitian rank 2 operation
*
*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an
*  n by n hermitian matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX         .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX          array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX          array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX            ZERO
X      PARAMETER        ( ZERO = ( 0.0E+0, 0.0E+0 ) )
*     .. Local Scalars ..
X      COMPLEX            TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          CONJG, REAL
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'CHPR2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*CONJG( Y( J ) )
X                  TEMP2 = CONJG( ALPHA*X( J ) )
X                  K     = KK
X                  DO 10, I = 1, J - 1
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   10             CONTINUE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) ) +
X     $                               REAL( X( J )*TEMP1 + Y( J )*TEMP2 )
X               ELSE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) )
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*CONJG( Y( JY ) )
X                  TEMP2 = CONJG( ALPHA*X( JX ) )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, K = KK, KK + J - 2
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X   30             CONTINUE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) ) +
X     $                               REAL( X( JX )*TEMP1 +
X     $                                     Y( JY )*TEMP2 )
X               ELSE
X                  AP( KK + J - 1 ) = REAL( AP( KK + J - 1 ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1   = ALPHA*CONJG( Y( J ) )
X                  TEMP2   = CONJG( ALPHA*X( J ) )
X                  AP( KK ) = REAL( AP( KK ) ) +
X     $                       REAL( X( J )*TEMP1 + Y( J )*TEMP2 )
X                  K        = KK               + 1
X                  DO 50, I = J + 1, N
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   50             CONTINUE
X               ELSE
X                  AP( KK ) = REAL( AP( KK ) )
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1    = ALPHA*CONJG( Y( JY ) )
X                  TEMP2    = CONJG( ALPHA*X( JX ) )
X                  AP( KK ) = REAL( AP( KK ) ) +
X     $                       REAL( X( JX )*TEMP1 + Y( JY )*TEMP2 )
X                  IX       = JX
X                  IY       = JY
X                  DO 70, K = KK + 1, KK + N - J
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X   70             CONTINUE
X               ELSE
X                  AP( KK ) = REAL( AP( KK ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of CHPR2 .
*
X      END
SHAR_EOF
chmod 0664 chpr2.f ||
echo 'restore of chpr2.f failed'
Wc_c="`wc -c < 'chpr2.f'`"
test 8601 -eq "$Wc_c" ||
	echo 'chpr2.f: original size 8601, current size' "$Wc_c"
fi
# ============= zhpr2.f ==============
if test -f 'zhpr2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping zhpr2.f (File already exists)'
else
echo 'x - extracting zhpr2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zhpr2.f' &&
*
************************************************************************
*
X      SUBROUTINE ZHPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*     .. Scalar Arguments ..
X      COMPLEX*16         ALPHA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      COMPLEX*16         AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  ZHPR2  performs the hermitian rank 2 operation
*
*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an
*  n by n hermitian matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - COMPLEX*16      .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - COMPLEX*16       array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  AP     - COMPLEX*16       array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the hermitian matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*           Note that the imaginary parts of the diagonal elements need
*           not be set, they are assumed to be zero, and on exit they
*           are set to zero.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      COMPLEX*16         ZERO
X      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )
*     .. Local Scalars ..
X      COMPLEX*16         TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          DCONJG, DBLE
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'ZHPR2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*DCONJG( Y( J ) )
X                  TEMP2 = DCONJG( ALPHA*X( J ) )
X                  K     = KK
X                  DO 10, I = 1, J - 1
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   10             CONTINUE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) ) +
X     $                               DBLE( X( J )*TEMP1 + Y( J )*TEMP2 )
X               ELSE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) )
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*DCONJG( Y( JY ) )
X                  TEMP2 = DCONJG( ALPHA*X( JX ) )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, K = KK, KK + J - 2
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X   30             CONTINUE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) ) +
X     $                               DBLE( X( JX )*TEMP1 +
X     $                                     Y( JY )*TEMP2 )
X               ELSE
X                  AP( KK + J - 1 ) = DBLE( AP( KK + J - 1 ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1   = ALPHA*DCONJG( Y( J ) )
X                  TEMP2   = DCONJG( ALPHA*X( J ) )
X                  AP( KK ) = DBLE( AP( KK ) ) +
X     $                       DBLE( X( J )*TEMP1 + Y( J )*TEMP2 )
X                  K        = KK               + 1
X                  DO 50, I = J + 1, N
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   50             CONTINUE
X               ELSE
X                  AP( KK ) = DBLE( AP( KK ) )
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1    = ALPHA*DCONJG( Y( JY ) )
X                  TEMP2    = DCONJG( ALPHA*X( JX ) )
X                  AP( KK ) = DBLE( AP( KK ) ) +
X     $                       DBLE( X( JX )*TEMP1 + Y( JY )*TEMP2 )
X                  IX       = JX
X                  IY       = JY
X                  DO 70, K = KK + 1, KK + N - J
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X   70             CONTINUE
X               ELSE
X                  AP( KK ) = DBLE( AP( KK ) )
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of ZHPR2 .
*
X      END
SHAR_EOF
chmod 0664 zhpr2.f ||
echo 'restore of zhpr2.f failed'
Wc_c="`wc -c < 'zhpr2.f'`"
test 8610 -eq "$Wc_c" ||
	echo 'zhpr2.f: original size 8610, current size' "$Wc_c"
fi
# ============= dsyr.f ==============
if test -f 'dsyr.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dsyr.f (File already exists)'
else
echo 'x - extracting dsyr.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dsyr.f' &&
*
************************************************************************
*
X      SUBROUTINE DSYR  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DSYR   performs the symmetric rank 1 operation
*
*     A := alpha*x*x' + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n symmetric matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the symmetric matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the symmetric matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSYR  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in upper triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  DO 10, I = 1, J
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   10             CONTINUE
X               END IF
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = KX
X                  DO 30, I = 1, J
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X                     IX        = IX        + INCX
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in lower triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  DO 50, I = J, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   50             CONTINUE
X               END IF
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = JX
X                  DO 70, I = J, N
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X                     IX        = IX        + INCX
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSYR  .
*
X      END
SHAR_EOF
chmod 0664 dsyr.f ||
echo 'restore of dsyr.f failed'
Wc_c="`wc -c < 'dsyr.f'`"
test 6041 -eq "$Wc_c" ||
	echo 'dsyr.f: original size 6041, current size' "$Wc_c"
fi
# ============= ssyr.f ==============
if test -f 'ssyr.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ssyr.f (File already exists)'
else
echo 'x - extracting ssyr.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ssyr.f' &&
*
************************************************************************
*
X      SUBROUTINE SSYR  ( UPLO, N, ALPHA, X, INCX, A, LDA )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  SSYR   performs the symmetric rank 1 operation
*
*     A := alpha*x*x' + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n symmetric matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the symmetric matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the symmetric matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSYR  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in upper triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  DO 10, I = 1, J
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   10             CONTINUE
X               END IF
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = KX
X                  DO 30, I = 1, J
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X                     IX        = IX        + INCX
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in lower triangle.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  DO 50, I = J, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP
X   50             CONTINUE
X               END IF
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = JX
X                  DO 70, I = J, N
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP
X                     IX        = IX        + INCX
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSYR  .
*
X      END
SHAR_EOF
chmod 0664 ssyr.f ||
echo 'restore of ssyr.f failed'
Wc_c="`wc -c < 'ssyr.f'`"
test 6041 -eq "$Wc_c" ||
	echo 'ssyr.f: original size 6041, current size' "$Wc_c"
fi
# ============= dspr.f ==============
if test -f 'dspr.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dspr.f (File already exists)'
else
echo 'x - extracting dspr.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dspr.f' &&
*
************************************************************************
*
X      SUBROUTINE DSPR  ( UPLO, N, ALPHA, X, INCX, AP )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DSPR    performs the symmetric rank 1 operation
*
*     A := alpha*x*x' + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n symmetric matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  AP     - DOUBLE PRECISION array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSPR  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  K    = KK
X                  DO 10, I = 1, J
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   10             CONTINUE
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = KX
X                  DO 30, K = KK, KK + J - 1
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X                     IX      = IX      + INCX
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  K    = KK
X                  DO 50, I = J, N
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   50             CONTINUE
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = JX
X                  DO 70, K = KK, KK + N - J
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X                     IX      = IX      + INCX
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSPR  .
*
X      END
SHAR_EOF
chmod 0664 dspr.f ||
echo 'restore of dspr.f failed'
Wc_c="`wc -c < 'dspr.f'`"
test 6081 -eq "$Wc_c" ||
	echo 'dspr.f: original size 6081, current size' "$Wc_c"
fi
# ============= sspr.f ==============
if test -f 'sspr.f' -a X"$1" != X"-c"; then
	echo 'x - skipping sspr.f (File already exists)'
else
echo 'x - extracting sspr.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'sspr.f' &&
*
************************************************************************
*
X      SUBROUTINE SSPR  ( UPLO, N, ALPHA, X, INCX, AP )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               AP( * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  SSPR    performs the symmetric rank 1 operation
*
*     A := alpha*x*x' + A,
*
*  where alpha is a real scalar, x is an n element vector and A is an
*  n by n symmetric matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  AP     - REAL             array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP
X      INTEGER            I, INFO, IX, J, JX, K, KK, KX
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSPR  ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set the start point in X if the increment is not unity.
*
X      IF( INCX.LE.0 )THEN
X         KX = 1 - ( N - 1 )*INCX
X      ELSE IF( INCX.NE.1 )THEN
X         KX = 1
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 20, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  K    = KK
X                  DO 10, I = 1, J
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   10             CONTINUE
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            JX = KX
X            DO 40, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = KX
X                  DO 30, K = KK, KK + J - 1
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X                     IX      = IX      + INCX
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( INCX.EQ.1 )THEN
X            DO 60, J = 1, N
X               IF( X( J ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( J )
X                  K    = KK
X                  DO 50, I = J, N
X                     AP( K ) = AP( K ) + X( I )*TEMP
X                     K       = K       + 1
X   50             CONTINUE
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            JX = KX
X            DO 80, J = 1, N
X               IF( X( JX ).NE.ZERO )THEN
X                  TEMP = ALPHA*X( JX )
X                  IX   = JX
X                  DO 70, K = KK, KK + N - J
X                     AP( K ) = AP( K ) + X( IX )*TEMP
X                     IX      = IX      + INCX
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSPR  .
*
X      END
SHAR_EOF
chmod 0664 sspr.f ||
echo 'restore of sspr.f failed'
Wc_c="`wc -c < 'sspr.f'`"
test 6081 -eq "$Wc_c" ||
	echo 'sspr.f: original size 6081, current size' "$Wc_c"
fi
# ============= dsyr2.f ==============
if test -f 'dsyr2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dsyr2.f (File already exists)'
else
echo 'x - extracting dsyr2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dsyr2.f' &&
*
************************************************************************
*
X      SUBROUTINE DSYR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DSYR2  performs the symmetric rank 2 operation
*
*     A := alpha*x*y' + alpha*y*x' + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an n
*  by n symmetric matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the symmetric matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the symmetric matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSYR2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  DO 10, I = 1, J
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   10             CONTINUE
X               END IF
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, I = 1, J
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  DO 50, I = J, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   50             CONTINUE
X               END IF
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = JX
X                  IY    = JY
X                  DO 70, I = J, N
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSYR2 .
*
X      END
SHAR_EOF
chmod 0664 dsyr2.f ||
echo 'restore of dsyr2.f failed'
Wc_c="`wc -c < 'dsyr2.f'`"
test 7419 -eq "$Wc_c" ||
	echo 'dsyr2.f: original size 7419, current size' "$Wc_c"
fi
# ============= ssyr2.f ==============
if test -f 'ssyr2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping ssyr2.f (File already exists)'
else
echo 'x - extracting ssyr2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ssyr2.f' &&
*
************************************************************************
*
X      SUBROUTINE SSYR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, INCY, LDA, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SSYR2  performs the symmetric rank 2 operation
*
*     A := alpha*x*y' + alpha*y*x' + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an n
*  by n symmetric matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the array A is to be referenced as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the upper triangular part of A
*                                  is to be referenced.
*
*              UPLO = 'L' or 'l'   Only the lower triangular part of A
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - REAL             array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular part of the symmetric matrix and the strictly
*           lower triangular part of A is not referenced. On exit, the
*           upper triangular part of the array A is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular part of the symmetric matrix and the strictly
*           upper triangular part of A is not referenced. On exit, the
*           lower triangular part of the array A is overwritten by the
*           lower triangular part of the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
X      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
X         INFO = 9
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSYR2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through the triangular part
*     of A.
*
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when A is stored in the upper triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  DO 10, I = 1, J
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   10             CONTINUE
X               END IF
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, I = 1, J
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when A is stored in the lower triangle.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  DO 50, I = J, N
X                     A( I, J ) = A( I, J ) + X( I )*TEMP1 + Y( I )*TEMP2
X   50             CONTINUE
X               END IF
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = JX
X                  IY    = JY
X                  DO 70, I = J, N
X                     A( I, J ) = A( I, J ) + X( IX )*TEMP1
X     $                                     + Y( IY )*TEMP2
X                     IX        = IX        + INCX
X                     IY        = IY        + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSYR2 .
*
X      END
SHAR_EOF
chmod 0664 ssyr2.f ||
echo 'restore of ssyr2.f failed'
Wc_c="`wc -c < 'ssyr2.f'`"
test 7419 -eq "$Wc_c" ||
	echo 'ssyr2.f: original size 7419, current size' "$Wc_c"
fi
# ============= dspr2.f ==============
if test -f 'dspr2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping dspr2.f (File already exists)'
else
echo 'x - extracting dspr2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dspr2.f' &&
*
************************************************************************
*
X      SUBROUTINE DSPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*     .. Scalar Arguments ..
X      DOUBLE PRECISION   ALPHA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      DOUBLE PRECISION   AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DSPR2  performs the symmetric rank 2 operation
*
*     A := alpha*x*y' + alpha*y*x' + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an
*  n by n symmetric matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  AP     - DOUBLE PRECISION array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      DOUBLE PRECISION   ZERO
X      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
X      DOUBLE PRECISION   TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'DSPR2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  K     = KK
X                  DO 10, I = 1, J
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   10             CONTINUE
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, K = KK, KK + J - 1
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  K     = KK
X                  DO 50, I = J, N
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   50             CONTINUE
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = JX
X                  IY    = JY
X                  DO 70, K = KK, KK + N - J
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of DSPR2 .
*
X      END
SHAR_EOF
chmod 0664 dspr2.f ||
echo 'restore of dspr2.f failed'
Wc_c="`wc -c < 'dspr2.f'`"
test 7358 -eq "$Wc_c" ||
	echo 'dspr2.f: original size 7358, current size' "$Wc_c"
fi
# ============= sspr2.f ==============
if test -f 'sspr2.f' -a X"$1" != X"-c"; then
	echo 'x - skipping sspr2.f (File already exists)'
else
echo 'x - extracting sspr2.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'sspr2.f' &&
*
************************************************************************
*
X      SUBROUTINE SSPR2 ( UPLO, N, ALPHA, X, INCX, Y, INCY, AP )
*     .. Scalar Arguments ..
X      REAL               ALPHA
X      INTEGER            INCX, INCY, N
X      CHARACTER*1        UPLO
*     .. Array Arguments ..
X      REAL               AP( * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  SSPR2  performs the symmetric rank 2 operation
*
*     A := alpha*x*y' + alpha*y*x' + A,
*
*  where alpha is a scalar, x and y are n element vectors and A is an
*  n by n symmetric matrix, supplied in packed form.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the upper or lower
*           triangular part of the matrix A is supplied in the packed
*           array AP as follows:
*
*              UPLO = 'U' or 'u'   The upper triangular part of A is
*                                  supplied in AP.
*
*              UPLO = 'L' or 'l'   The lower triangular part of A is
*                                  supplied in AP.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - REAL            .
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - REAL             array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  AP     - REAL             array of DIMENSION at least
*           ( ( n*( n + 1 ) )/2 ).
*           Before entry with  UPLO = 'U' or 'u', the array AP must
*           contain the upper triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
*           and a( 2, 2 ) respectively, and so on. On exit, the array
*           AP is overwritten by the upper triangular part of the
*           updated matrix.
*           Before entry with UPLO = 'L' or 'l', the array AP must
*           contain the lower triangular part of the symmetric matrix
*           packed sequentially, column by column, so that AP( 1 )
*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
*           and a( 3, 1 ) respectively, and so on. On exit, the array
*           AP is overwritten by the lower triangular part of the
*           updated matrix.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
X      REAL               ZERO
X      PARAMETER        ( ZERO = 0.0E+0 )
*     .. Local Scalars ..
X      REAL               TEMP1, TEMP2
X      INTEGER            I, INFO, IX, IY, J, JX, JY, K, KK, KX, KY
*     .. External Functions ..
X      LOGICAL            LSAME
X      EXTERNAL           LSAME
*     .. External Subroutines ..
X      EXTERNAL           XERBLA
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
X      INFO = 0
X      IF     ( .NOT.LSAME( UPLO, 'U' ).AND.
X     $         .NOT.LSAME( UPLO, 'L' )      )THEN
X         INFO = 1
X      ELSE IF( N.LT.0 )THEN
X         INFO = 2
X      ELSE IF( INCX.EQ.0 )THEN
X         INFO = 5
X      ELSE IF( INCY.EQ.0 )THEN
X         INFO = 7
X      END IF
X      IF( INFO.NE.0 )THEN
X         CALL XERBLA( 'SSPR2 ', INFO )
X         RETURN
X      END IF
*
*     Quick return if possible.
*
X      IF( ( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
X     $   RETURN
*
*     Set up the start points in X and Y if the increments are not both
*     unity.
*
X      IF( ( INCX.NE.1 ).OR.( INCY.NE.1 ) )THEN
X         IF( INCX.GT.0 )THEN
X            KX = 1
X         ELSE
X            KX = 1 - ( N - 1 )*INCX
X         END IF
X         IF( INCY.GT.0 )THEN
X            KY = 1
X         ELSE
X            KY = 1 - ( N - 1 )*INCY
X         END IF
X         JX = KX
X         JY = KY
X      END IF
*
*     Start the operations. In this version the elements of the array AP
*     are accessed sequentially with one pass through AP.
*
X      KK = 1
X      IF( LSAME( UPLO, 'U' ) )THEN
*
*        Form  A  when upper triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 20, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  K     = KK
X                  DO 10, I = 1, J
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   10             CONTINUE
X               END IF
X               KK = KK + J
X   20       CONTINUE
X         ELSE
X            DO 40, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = KX
X                  IY    = KY
X                  DO 30, K = KK, KK + J - 1
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X   30             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + J
X   40       CONTINUE
X         END IF
X      ELSE
*
*        Form  A  when lower triangle is stored in AP.
*
X         IF( ( INCX.EQ.1 ).AND.( INCY.EQ.1 ) )THEN
X            DO 60, J = 1, N
X               IF( ( X( J ).NE.ZERO ).OR.( Y( J ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( J )
X                  TEMP2 = ALPHA*X( J )
X                  K     = KK
X                  DO 50, I = J, N
X                     AP( K ) = AP( K ) + X( I )*TEMP1 + Y( I )*TEMP2
X                     K       = K       + 1
X   50             CONTINUE
X               END IF
X               KK = KK + N - J + 1
X   60       CONTINUE
X         ELSE
X            DO 80, J = 1, N
X               IF( ( X( JX ).NE.ZERO ).OR.( Y( JY ).NE.ZERO ) )THEN
X                  TEMP1 = ALPHA*Y( JY )
X                  TEMP2 = ALPHA*X( JX )
X                  IX    = JX
X                  IY    = JY
X                  DO 70, K = KK, KK + N - J
X                     AP( K ) = AP( K ) + X( IX )*TEMP1 + Y( IY )*TEMP2
X                     IX      = IX      + INCX
X                     IY      = IY      + INCY
X   70             CONTINUE
X               END IF
X               JX = JX + INCX
X               JY = JY + INCY
X               KK = KK + N - J + 1
X   80       CONTINUE
X         END IF
X      END IF
*
X      RETURN
*
*     End of SSPR2 .
*
X      END
SHAR_EOF
chmod 0664 sspr2.f ||
echo 'restore of sspr2.f failed'
Wc_c="`wc -c < 'sspr2.f'`"
test 7358 -eq "$Wc_c" ||
	echo 'sspr2.f: original size 7358, current size' "$Wc_c"
fi
# ============= lsame.f ==============
if test -f 'lsame.f' -a X"$1" != X"-c"; then
	echo 'x - skipping lsame.f (File already exists)'
else
echo 'x - extracting lsame.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'lsame.f' &&
X      LOGICAL          FUNCTION LSAME( CA, CB )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
X      CHARACTER          CA, CB
*     ..
*
*  Purpose
*  =======
*
*  LSAME returns .TRUE. if CA is the same letter as CB regardless of
*  case.
*
*  Arguments
*  =========
*
*  CA      (input) CHARACTER*1
*  CB      (input) CHARACTER*1
*          CA and CB specify the single characters to be compared.
*
*     .. Intrinsic Functions ..
X      INTRINSIC          ICHAR
*     ..
*     .. Local Scalars ..
X      INTEGER            INTA, INTB, ZCODE
*     ..
*     .. Executable Statements ..
*
*     Test if the characters are equal
*
X      LSAME = CA.EQ.CB
X      IF( LSAME )
X     $   RETURN
*
*     Now test for equivalence if both characters are alphabetic.
*
X      ZCODE = ICHAR( 'Z' )
*
*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime
*     machines, on which ICHAR returns a value with bit 8 set.
*     ICHAR('A') on Prime machines returns 193 which is the same as
*     ICHAR('A') on an EBCDIC machine.
*
X      INTA = ICHAR( CA )
X      INTB = ICHAR( CB )
*
X      IF( ZCODE.EQ.90 .OR. ZCODE.EQ.122 ) THEN
*
*        ASCII is assumed - ZCODE is the ASCII code of either lower or
*        upper case 'Z'.
*
X         IF( INTA.GE.97 .AND. INTA.LE.122 ) INTA = INTA - 32
X         IF( INTB.GE.97 .AND. INTB.LE.122 ) INTB = INTB - 32
*
X      ELSE IF( ZCODE.EQ.233 .OR. ZCODE.EQ.169 ) THEN
*
*        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
*        upper case 'Z'.
*
X         IF( INTA.GE.129 .AND. INTA.LE.137 .OR.
X     $       INTA.GE.145 .AND. INTA.LE.153 .OR.
X     $       INTA.GE.162 .AND. INTA.LE.169 ) INTA = INTA + 64
X         IF( INTB.GE.129 .AND. INTB.LE.137 .OR.
X     $       INTB.GE.145 .AND. INTB.LE.153 .OR.
X     $       INTB.GE.162 .AND. INTB.LE.169 ) INTB = INTB + 64
*
X      ELSE IF( ZCODE.EQ.218 .OR. ZCODE.EQ.250 ) THEN
*
*        ASCII is assumed, on Prime machines - ZCODE is the ASCII code
*        plus 128 of either lower or upper case 'Z'.
*
X         IF( INTA.GE.225 .AND. INTA.LE.250 ) INTA = INTA - 32
X         IF( INTB.GE.225 .AND. INTB.LE.250 ) INTB = INTB - 32
X      END IF
X      LSAME = INTA.EQ.INTB
*
*     RETURN
*
*     End of LSAME
*
X      END
SHAR_EOF
chmod 0644 lsame.f ||
echo 'restore of lsame.f failed'
Wc_c="`wc -c < 'lsame.f'`"
test 2405 -eq "$Wc_c" ||
	echo 'lsame.f: original size 2405, current size' "$Wc_c"
fi
# ============= xerbla.f ==============
if test -f 'xerbla.f' -a X"$1" != X"-c"; then
	echo 'x - skipping xerbla.f (File already exists)'
else
echo 'x - extracting xerbla.f (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xerbla.f' &&
X      SUBROUTINE XERBLA ( SRNAME, INFO )
*     ..    Scalar Arguments ..
X      INTEGER            INFO
X      CHARACTER*6        SRNAME
*     ..
*
*  Purpose
*  =======
*
*  XERBLA  is an error handler for the Level 2 BLAS routines.
*
*  It is called by the Level 2 BLAS routines if an input parameter is
*  invalid.
*
*  Installers should consider modifying the STOP statement in order to
*  call system-specific exception-handling facilities.
*
*  Parameters
*  ==========
*
*  SRNAME - CHARACTER*6.
*           On entry, SRNAME specifies the name of the routine which
*           called XERBLA.
*
*  INFO   - INTEGER.
*           On entry, INFO specifies the position of the invalid
*           parameter in the parameter-list of the calling routine.
*
*
*  Auxiliary routine for Level 2 Blas.
*
*  Written on 20-July-1986.
*
*     .. Executable Statements ..
*
X      WRITE (*,99999) SRNAME, INFO
*
X      STOP
*
99999 FORMAT ( ' ** On entry to ', A6, ' parameter number ', I2,
X     $         ' had an illegal value' )
*
*     End of XERBLA.
*
X      END
SHAR_EOF
chmod 0664 xerbla.f ||
echo 'restore of xerbla.f failed'
Wc_c="`wc -c < 'xerbla.f'`"
test 1055 -eq "$Wc_c" ||
	echo 'xerbla.f: original size 1055, current size' "$Wc_c"
fi
exit 0
